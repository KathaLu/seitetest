<html lang:"de"="">
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css" type="text/css">
    <title>IT3 E-Portfolio</title>
    
  </head>
<!-- Body Bereich -->     
<body>
  <div id="inhalt" class="inhalt">
    <h1 class="Vorlesungen">Vorlesungen</h1>
    <p class="Vorlesungen">Unter diesem Reiter finden Sie meine beiden Zusammenfassungen zu den Vorlesungen â€Programmieren in einer objektorientierten Umgebungâ€œ und â€Fundamentale Ideen der Informatikâ€. Viel SpaÃŸ beim DurchstÃ¶bern!ğŸ™‚</p>
     
      <h2 class="Programmieren in einer objektorientierten Umgebung">Programmieren in einer objektorientierten Umgebung</h2>
      <p class="Programmieren in einer objektorientierten Umgebung"> <b>1. EINFÃœHRUNG IN RUBY</b> <br> <br>
Ruby wurde zwei Jahre lang von Yukihiro Matsumoto entwickelt, und im Jahr 1995 verÃ¶ffentlicht. Bis dahin war Ruby eine vollkommen unbekannte Sprache. 2004 wurde das Webframework Ruby on Rails verÃ¶ffentlicht, und Rubys Durchbruch erfolgte. Heute gehÃ¶rt Ruby zu den am meist verbreiteten Programmiersprachen der Welt.
Ruby ist eine sogenannte interpretierte Skriptsprache. Das bedeutet, ein Ruby-Programm wird vom Ruby-Interpreter geÃ¶ffnet, Zeile fÃ¼r Zeile gelesen und die Ruby-Anweisungen in Maschinensprache Ã¼bersetzt. Um also ein Ruby-Programm ausfÃ¼hren zu kÃ¶nnen, muss auf dem Rechner ein entsprechender Interpreter installiert sein.
Ruby ist auÃŸerdem eine objektorientierte Sprache, was heiÃŸt, dass jeder Wert ein Objekt ist, und jedes Objekt zu einer Klasse gehÃ¶rt.</p>
      <br> 
      <b> WARUM RUBY?</b> <br>
Ruby ist eine freie Programmiersprache, das heiÃŸt also, dass diese kostenlos, frei zu benutzen, zu kopieren, zu verÃ¤ndern und zu verbreiten ist. AuÃŸerdem bietet Ruby einen guten Einstieg in die Programmierung, da es relativ einfach zu lernen ist. Die Befehle kÃ¶nnen dazu auch besser verstanden werden, da sie an der englischen Sprache orientiert sein. Dazu unterstÃ¼tzt Ruby die neuesten, wichtigen Programmiermethodiken: Objektorientierung, XP, und auch mehrere Programmierparadigmen. Ein weiterer sehr wichtiger Aspekt ist, dass Ruby der menschlichen Denkweise sehr Ã¤hnelt. <br> <br>
<b> EXKURS </b> <br> <br>
 ASSEMBLER<br>
â†’ fÃ¼r den Menschen lesbare Sprache <br>
â†’ Umwandlung in Maschinensprache notwendig <br>
â†’ zu umstÃ¤ndlich und fehleranfÃ¤llig <br> <br>
      COMPILER<br>
â†’ Ã¼bersetzt das in Hochsprache formulierte Programm in Maschinensprache, das dann ausgefÃ¼hrt werden kann <br> <br>
      INTERPRETER <br>
â†’ analysiert das in Hochsprache formulierte Programm und aktiviert direkt die entsprechenden Maschinenbefehle <br> <br>
      <b>ALGORITHMEN UND PROGRAMME</b> <br>
Algorithmen sind genau definierte Handlungsvorschriften die zur LÃ¶sung eines Problems dienen. Ein dafÃ¼r alltÃ¤gliches Beispiel sind Kochrezepte, in welchem beschrieben wird, in welcher Reihenfolge Schritte zu erledigen sind.
Programme sind konkrete Formen von Algorithmen. Diese bestehen aus mehreren Anweisungen, die dann vom Computer interpretiert, und in der Reihenfolge durchgefÃ¼hrt werden. <br> <br>
      <b>ERSTE ANWEISUNGEN</b> <br>
Ãœblicherweise wird eine einfache Anweisung in eine Zeile geschrieben. Diese orientiere sich an der natÃ¼rlichen, also englischen Sprache.<br>
puts â€“ es erfolgt eine Ausgabe mit Zeilenumbruch <br>
print â€“ es erfolgt eine Ausgabe ohne Zeilenumbruch <br>
Raute (#) â€“ hierbei handelt es sich um einen Kommentar; die Raute und alles das in der Zeile danach steht wird vom Ruby-Interpreter ignoriert <br>
#=> â€“ eine Raute mit einem darauffolgenden Pfeil zeigt an, welcher Wert bei dem Code herauskommen wÃ¼rde, wenn man ihn ausfÃ¼hren wÃ¼rde <br> <br>
      <b>2. DATENTYPEN UND VARIABLEN </b> <br> <br>

      <b> DATENTYPEN </b> <br>
Daten, ihre AusfÃ¼hrung und Manipulation bilden die Basis von Computerprogrammen. In Ruby sind folgende, einfache und komplexe Datentypen vordefiniert: <br><br>

      <b>EINFACHE DATENTYPEN</b> <br>

Zahlen: â€¦werden in Ruby meist wie im realen Leben eingesetzt; zum Rechnen, als Index, etc. Unterschieden wird zwischen ganzzahligen Werten (Integer wie 1; -1; 1000) und FlieÃŸkommazahlen (Float wie 1.2; 3.06; -6.66) <br>

Zeichen: â€¦ist ein einzelner Buchstabe, Ziffer, Leerzeichen oder sonstiges typografisches Symbol. <br>

Zeichenketten (String): â€¦eine Kette von Zeichen (Buchstaben, Zahlen etc.) umschlossen von einfachen oder doppelten AnfÃ¼hrungszeichen <br>

String-Interpolation â€“ Besonderheit:Strings in doppelten AnfÃ¼hrungszeichen kÃ¶nnen beliebige Ruby-AusdrÃ¼cke beinhalten. 

Wenn der String erzeugt wird, wird der Ausdruck ausgewertet, in einen String konvertiert und anstelle des Ausdrucks selbst in die Zeichenkette eingefÃ¼gt.

AusdrÃ¼cke innerhalb eines Strings beginnen mit dem Raute-Zeichen (#) und werden von geschweiften Klammern ({ }) umschlossen:

puts â€1 + 2 = #{1+2}â€œ #=> 1 + 2 = 3

Boolean / Boolsche Werte: â€¦logische Aussage, kann wahr (true), falsch (false) oder leer (nil) sein

In manchen FÃ¤llen ist eine Umwandlung der Datentypen notwendig. Ein Beispiel finden Sie in der ersten Ãœbung zu diesem Kapitel. HierfÃ¼r gibt es folgende Befehle:<br><br>

      <b>UMWANDLUNG DER DATENTYPEN</b> <br>
      to_s â€“ Umwandlung zu einem String
      to_i â€“ Umwandlung zu einem Integer
      .to_f â€“ Umwandlung zu einem Float <br> <br>

      <b> VARIABLEN</b> <br>

Variablen haben in Programmiersprachen eine wichtige Rolle. Sie erleichtern einem das Nutzen und Schreiben von Programmen. Wird einer Variable einmal ein Wert zugeordnet, kann dieser beliebig oft genutzt und aufgerufen werden.
Variablen kann man sich wie ein GefÃ¤ÃŸ vorstellen, in dem ein Wert hinterlegt wird. Variablen kÃ¶nnen anhand von beliebigen Datentypen hinterlegt werden. Egal ob String, Boolean, oder einfach nur eine Zahl.
Es wird weiter unterschieden zwischen lokalen und globalen Variablen.
Lokale Variablen werden entweder durch einen Unterstrich oder einen Kleinbuchstaben zu Beginn der Variable gekennzeichnet. Sie gelten fÃ¼r die Methode, fÃ¼r die sie definiert werden. Wenn aber eine Methode bereits eine Variable verwendet, greift sie auf diese zurÃ¼ck, und erstellt keine neue.
Globale Variablen werden mit einem $ gekennzeichnet. Diese sind immer und Ã¼berall im Ruby Programm sichtbar. Es gibt auch globale Variablen, die keinen zugewiesenen Wert haben, besitzen dann automatisch den Wert nil. <br> <br>
      <b> LITERALE UND AUSDRÃœCKE</b> <br><br>

      <b>LITERALE</b> <br>

Um bestimmte AusdrÃ¼cke zu erzeugen, gibt es eine Art Kurzsyntax, die Literale. Einfach ausgedrÃ¼ckt sind Literale Abfolgen von Ziffern und Zahlen.
â€˜ein String Literalâ€™ <br> <br>
      <b>AUSDRÃœCKE</b><br>
Ein Ausdruck ist ein StÃ¼ck Code, der vom Ruby-Interpreter ausgewertet wird, um einen Wert zu erzeugen. PrimÃ¤rausdrÃ¼cke sind die einfachsten mÃ¶glichen AusdrÃ¼cke, die nicht aus einfacheren AusdrÃ¼cken zusammengesetzt sind. Dazu gehÃ¶ren Literale, Referenzen auf Variablen und Aufrufe von Methoden.
Es kÃ¶nnen ebenfalls grÃ¶ÃŸere AusdrÃ¼cke erzeugt werden. Dies erfolgt indem man PrimÃ¤rausdrÃ¼cke durch Operatoren kombiniert werden. <br> <br>
      <b>3. ANWEISUNGEN UND FUNKTIONEN</b><br><br>

      <b>OPERATOREN</b> <br>

Ein Ausdruck wird Ã¼blicherweise aus Werten und Operatoren gebildet. Hierbei gibt es unter anderem die arithmetischen Operatoren, Zuweisungsoperatoren oder logischen Operatoren.<br> <br>
      <b> FUNKTIONEN</b><br>
Funktionen sind CodeblÃ¶cke, die einmal definiert werden und auf die dann beliebig oft zurÃ¼ckgegriffen werden kann. So lÃ¤sst sich ein Programm besser strukturieren und der Code kompakt halten.
Die zwei SchlÃ¼sselwÃ¶rter fÃ¼r Definitionen sind def und end. Man beginnt mit â€œdefâ€, woraufhin der Funktionsname und optionale ein oder mehrere Parameter in Klammern folgen.
Im Funktionsrumpf befindet sich der Ruby-Code, der bei Aufruf der Funktion ausgefÃ¼hrt wird. Die Parameter werden hier wie normale Variablen verwendet. Das Ende wird dann mit â€œendâ€ gekennzeichnet.
Allgemein formuliert sieht dies dann so aus:
def name (parameter)
Funktionsrumpf
â€¦
â€¦
end <br> <br>
      <b>4. KONTROLLSTRUKTUREN</b> <br><br>

Kontrollstrukturen dienen dazu den geradlinigen Programmfluss zu unterbrechen und an anderen Stellen zu verzweigen. Dies geschieht in Form von Fallentscheidungen oder Schleifen.<br><br>

      <b>FALLENTSCHEIDUNGEN</b><br>

Das wichtige bei Fallentscheidungen ist, dass sie immer mindestens eine, oder mehrere Bedingungen enthalten. Je nach dem ob die Bedingung erfÃ¼llt ist, oder nicht, wird ein bestimmtes StÃ¼ck Code ausgefÃ¼hrt.<br>

â†’ Es handelt sich hierbei also um Boolâ€™sche AusdrÃ¼cke. Anweisungen werden dann ausgefÃ¼hrt, je nach dem, ob eine Bedingung true oder false ist.<br><br>

      <b>SCHLEIFEN</b><br>
Schleifen bewirken, dass ein Code-StÃ¼ck wiederholt und somit mehrmals ausgefÃ¼hrt wird.<br><br>
      
      <b>  ITERATOREN</b> <br>

Eine Alternative Wiederholungen zu erzeugen, wird durch Iteratoren geboten. Ein Iterator schreitet durch eine Liste von Elementen und arbeitet diese Element fÃ¼r Element ab. Unter anderem gibt es die numerischen Iteratoren times, upto und downto.
Die Methode times ruft ihren zugehÃ¶rigen Codeblock genau n-mal auf. (Sie geht also durch eine Liste aufeinanderfolgender Zahlen mit n Elementen beginnend bei 0. Dies kann so aussehen:
3.times do
print â€œhaha!â€
end
# => haha!haha!haha!
Wird die Methode durch einen formalen Parameter erweitert, so zeigt dieser den Wert der aktuellen Iteration an und Ã¼bergibt ihn dem Codeblock:
3.times do |x|
print x
end
# => 012
Die Methode upto ruft ihren zugehÃ¶rigen Block einmal fÃ¼r jeden Wert auf, der zwischen dem Integer, fÃ¼r den sie aufgerufen wird und dem Integer, der als Argument Ã¼bergeben wird, liegt:
3.upto(5) do |x|
print x
end
# => 345
Die Methode downto funktioniert im Prinzip wie upto, nur anders herum, das heiÃŸt sie iteriert von der grÃ¶ÃŸeren zur kleineren Zahl:
5.downto(3) do |x|
print x
end
# => 543
Durch die Methode step kann eine verÃ¤nderte Schrittweite angegeben werden. Sie wird wie upto fÃ¼r einen Startwert aufgerufen, als Argumente werden ebenfalls der Endwert und zusÃ¤tzlich die Schrittweiter Ã¼bergeben:
3.step(5, 0.5) do |x|
print x
print â€œ;â€
end
# => 3.0;3.5;4.0;4.5;5.0 <br> <br>
      
     <b> CODEBLÃ–CKE </b><br>

Die Verwendung von BlÃ¶cken ist eine der Grundlagen der Verwendung von Iteratoren. Der Code zwischen do und end wird als Codeblock oder anonyme Funktion bezeichnet.

Ein Block kann nicht fÃ¼r sich allein stehen, sondern muss auf den Aufruf einer Methode folgen, der ihn ausfÃ¼hrt, wie es z.B. bei Iterationen der Fall ist.

BlÃ¶cke werden durch geschweifte Klammern oder die SchlÃ¼sselwÃ¶rter do und end umschlossen.{} bzw. do mÃ¼ssen sich dabei in der gleichen Zeile befinden wie der Methodenaufruf.

Der RÃ¼ckgabewert eines Blocks ist, wie auch bei Funktionen, der Wert des letzten Ausdrucks, der in dem Block ausgewertet wurde.

FÃ¼r die NamensrÃ¤ume von Variablen gilt:<br>

â†’ lokale Variablen, die innerhalb des Codeblocks erzeugt werden, sind auÃŸerhalb nicht verfÃ¼gbar<br>

â†’ existiert eine lokale Variable bereits auÃŸerhalb der Funktion, kann sie innerhalb verwendet werden, d.h. es wird keine neue Variable erzeugt<br> <br>

         <b>5. ARRAYS UND HASHES</b> <br><br>

         <b> ARRAYS</b><br>

Ein Array ist eine Liste mit mehreren Elementen. Die LÃ¤nge eines Arrays ist dynamisch, das heiÃŸt also, dass diese bei Bedarf mitwÃ¤chst.
Ein Array wird erzeugt, indem es mit einem Namen versehen wird, dem entweder [] oder Array.new zugewiesen wird:
liste = [ ]
liste = Array.new <br>
â†’ in diesen beiden FÃ¤llen ist das Array zunÃ¤chst leer<br>
â†’ soll es mit einer bestimmten LÃ¤nge erzeugt werden, wird beim Aufruf â€œArray.newâ€ in <br>
Klammern eine Zahl Ã¼bergeben:<br>
liste = Array.new(3)
Einem Array kÃ¶nnen auch direkt bei der Erstellung konkrete Werte Ã¼bergeben werden:
liste = [1,4,5,6,8]
liste = Array.new(3,â€Halloâ€)
# => [â€œHalloâ€, â€œHalloâ€, â€œHalloâ€] <br><br>

         <b>ZUGRIFF</b><br>

Der Zugriff auf einen bestimmten Wert im Array funktioniert Ã¼ber den Namen des Arrays und der Angabe der gewÃ¼nschten Stelle (dem Index) in eckigen Klammern:
liste = [2]
# => [5]
Es kann auch auf einen Teil, d.h. auf mehrere Werte im Array zugegriffen werden. Hierbei wird die erste und letzte Stelle im Array angegeben, auf deren Werte zugegriffen werden soll:
liste = [2..4]
# => [5,6,8] (also Zugriff auf die Werte an den Stellen 2 bis 4 im Array)
AuÃŸerdem kann ein Wert innerhalb des Arrays ersetzt werden:
liste[2] = 100
# => [1,4,100,6,8]
Bei negativen Indexzahlen erfolgt der Zugriff von hinten:
liste[-1] = [1,4,5,6,8]
# => [8] <br> <br>

         <b>METHODEN</b><br>

â†’ die LÃ¤nge von Arrays ist dynamisch und kann dementsprechend verÃ¤ndert werden:<br>
myArray.insert(stelle, wert)<br>
â†’ fÃ¼gt an der angegebenen Stelle ein neues Element ein und alle folgenden Elemente werden um eine Stelle nach hinten verschoben<br>
Beispielsweise so:
liste.insert(3, 10)
# => [1, 4, 100, 10, 6, 8]
myArray.delete(wert)
â†’ ebenso kÃ¶nnen bestimmte Werte im Array gelÃ¶scht werden, was dann so aussieht:
liste.delete(4)
# => [1, 100, 10, 6, 8]<br>
â†’ unter der Seite http://ruby-doc.org/core-2.5.0/Array.html findet man noch ganze viele andere Methoden, die man fÃ¼r Arrays anwenden kann!  <br> <br>   
       
         <b>  SORTIEREN</b><br>

Eine hÃ¤ufig auftretende Aufgabe in der Programmierung ist das Sortieren von Elementen innerhalb des Arrays. HierfÃ¼r wird unter anderem das Bubble-Sort Prinzip verwendet. Das Prinzip dabei ist, immer zwei nebeneinander liegende Elemente zu vergleichen und ggf. zu vertauschen.
Nebenstehend soll eine Reihe von Zahlen der GrÃ¶ÃŸe nach geordnet werden (GrÃ¶ÃŸtes nach rechts, Kleinstes nach links).
Jeweils zwei nebeneinander liegende Zahlen werden verglichen und die grÃ¶ÃŸere der beiden nach rechts verschoben.
Somit gelangt in einem Durchlauf die grÃ¶ÃŸte Zahl ganz nach rechts. Im nÃ¤chsten die zweitgrÃ¶ÃŸte Zahl an die zweite Stelle von rechts, usw.
Um die Reihe also vollstÃ¤ndig zu sortieren, werden n-1 DurchgÃ¤nge benÃ¶tigt.
Um nun konkret Werte in einem Array zu sortieren, wird Ã¼ber die Indexzahl auf die einzelnen Werte zugegriffen und diese miteinander verglichen. Um alle Werte zu erfassen, erfolgt dies in einer Schleife. Das heiÃŸt bei ersten Schleifendurchlauf wird der Wert an der Stelle 0 mit dem Wert an Stelle 1 vergleichen. Im nÃ¤chsten Durchlauf wird dann der Wert an Stelle 1 mit dem an Stelle 2 verglichen usw. Je nachdem, was ein Vergleich ergibt, werden die Werte an den Stellen vertauscht.<br> <br>
      
         <b>HASHES</b><br>

Ein Hash ist, wie ein Array, eine Menge von Werten. Anders als im Array sind diese allerdings nicht geordnet, sondern werden Ã¼ber einen SchlÃ¼ssel identifiziert. Das heiÃŸt fÃ¼r jeden SchlÃ¼ssel ist ein bestimmer Wert hinterlegt:
grauwerte = {â€œweissâ€=>255, â€œhellgrauâ€=> 100, â€œschwarzâ€=> 0}
Der Zugriff auf diese Werte erfolgt ebenfalls Ã¼ber den SchlÃ¼ssel:
grauwerte[â€œhellgrauâ€]
# => 100 <br> <br>

         <b>6. TEST-DRIVEN-DEVELOPMENT</b><br><br>

Test-Driven-Development bezeichnet eine Methode des Programmentwurfs bei der ein Programm schrittweise, begleitet von kontinuierlichem Testen entwickelt wird.   
         â†’ d. h. ein Teil des Programms wird entworfen, dann getestet und verbessert bis es keine Fehler mehr gibt <br>
â†’ dann wird das Programm erweitert, getestet, erweitert, getestet, und so weiter<br>
â†’ so sollen Fehler mÃ¶glichst frÃ¼h erkannt und gelÃ¶st werden<br>
Folgendes ist ein Beispiel dafÃ¼r:
Es soll eine neue Funktion erstellt werden, die testet, ob es sich bei einer Jahreszahl um ein Schaltjahr handelt.
Es gilt:<br>
â€“ ist die Zahl durch 4 teilbar, ist das Jahr ein Schaltjahr<br>
â€“ ist die Zahl durch 4 und durch 100 teilbar, ist das Jahr kein Schaltjahr<br>
â€“ ist die Zahl durch 4, 100 und 400 teilbar, ist das Jahr ein Schaltjahr<br>
Um die Funktion schrittweise zu entwickeln, wird nun zuerst ein Test erstellt:<br>
def assert( expression )
raise â€œFehler!â€ unless expression
end<br>
Der Test gibt eine Fehlermeldung aus, wenn der Ausdruck, fÃ¼r den er durchgefÃ¼hrt wird, nicht wahr ist.<br>
â†’ Nun geht es darum, das Programm schrittweise zu entwickeln und zwischendurch immer wieder zu testen.<br> <br>
      
      <b>7. OBJEKTORIENTIERUNG</b><br> <br>

Ruby ist eine objektorientierte Programmiersprache. Dies bedeutet, dass in einem Ruby-Programm Ideen umgesetzt und damit gearbeitet werden kann, wie man es auch im realen Leben tun wÃ¼rde.
So werden in einem Programm Klassen und Objekte erstellt, fÃ¼r die beliebige Eigenschaften und Beziehungen untereinander definiert werden kÃ¶nnen. Klassen sind sozusagen Vorlagen aus denen dann konkrete Objekte erzeugt werden. Innerhalb der Klasse kÃ¶nnen eine Reihe von Eigenschaften und Methoden definiert werden, die auf ein Objekt angewendet werden kÃ¶nnen.
Zur Veranschaulichung, hier ein Beispiel:<br>
â†’ es wird als erstes die Klasse â€œCatâ€ erstellt<br>
class Cat
attr_accessor :name, :age, :color
end
Der Name einer Klasse beginnt immer mit einem GroÃŸbuchstaben.
atrr_accessor definiert Instanzvariablen, das heiÃŸt Variablen, durch die Objekte der Klasse identifiziert werden kÃ¶nnen.
â†’ hier kann eine Instanz der Klasse Cat durch Name, Alter und Farbe identifiziert werden
â†’ aus dieser Klasse kÃ¶nnen nun Objekte erzeugt werden:
cat_instance = Cat.new
FÃ¼r das erzeugt Objekt kÃ¶nnen im nÃ¤chsten Schritt Attribute definiert werden:
cat_instance.name =â€Maxâ€
cat_instance.age = 3
cat_instance.color = â€œblackâ€
â†’ jetzt erzeuge ich eine neue Klasse Snake:
class = Snake
attr_accessor :name, :age, :color
end
! ein wichtiges Merkmal objektorientierter Sprachen ist die Vererbung â†’ somit ist es mÃ¶glich, fÃ¼r die Klassen â€œCatâ€ und â€œSnakeâ€ eine Superklasse â€œPetâ€ zu erzeugen â†’ â€œCatâ€ und â€œSnakeâ€ bilden also die Subklassen von â€œPetâ€ und erben damit alle Eigenschaften, die fÃ¼r die Klasse â€œPetâ€ zur VerfÃ¼gung stehen
â†’ also wird die Klasse â€œPetâ€ zunÃ¤chst definiert
class Pet
attr_accessor :name, :age, :color
end
â†’ jetzt werden die Subklassen definiert, dabei gibt â€œ<Petâ€ die Vererbung der Klasse Pet an
â†’ somit mÃ¼ssen Attribute, die fÃ¼r â€œPetâ€ gelten, fÃ¼r â€œCatâ€ und â€œSnakeâ€ nicht noch einmal definiert werden
class Cat < Pet
end
class Snake < Pet
end
â†’ es kÃ¶nnen allerdings aber auch spezifische Eigenschaften fÃ¼r einzelne Klassen hinzugefÃ¼gt werden
class Snake < Pet
attr_accessor :length
end
â†’ auÃŸerdem kÃ¶nnen bestimmte Methoden definiert werden, d. h. Anweisungen, die fÃ¼r Objekte der Klasse verwendet werden kÃ¶nnen
class Dog < Pet
def bark
puts â€œWoof!â€
end
end
â†’ wird nun ein neuer Hund erstellt, kann fÃ¼r diesen die Methode â€œbarkâ€ aufgerufen werden
a_dog = Dog.new
a_dog.bark
# => Woof!  <br><br>
      
      <b>8. SHOES UND RUBY</b> <br> <br>

 Shoes ist ein GUI-Framework fÃ¼r Ruby. GUI steht fÃ¼r â€graphical user interfaceâ€œ und ist eine grafische BenutzeroberflÃ¤che, mit denen User in Programmen interagieren kÃ¶nnen. Framework bedeutet â€GerÃ¼stâ€œ und man kann es als Vorprogrammierung verstehen. So sind in Shoes schon Funktionen und Elemente vorhanden und mÃ¼ssen nicht jedes Mal neu programmiert werden. Shoes kann auf verschiedene Weise verwendet und eingebunden werden. Shoes ermÃ¶glicht es also, fÃ¼r Ruby Programme eine graphische BenutzeroberflÃ¤che zu erstellen. Somit kann der Nutzer einfach mit einem Spiel/einer Webseite oder Ã¤hnlichem interagieren.
Shoes.app do
â€¦
â€¦
end
bildet das GrundgerÃ¼st im Ruby Programm
â†’ wird etwas nach dem â€œendâ€ geschrieben, wird es zwar in Ruby ausgefÃ¼hrt, in Shoes aber nicht<br><br>

      <b>ERSTE SHOES ANWENDUNG</b><br>

â†’ Textausgaben Ã¼ber puts und print sind nicht mehr mÃ¶glich, anstatt davon gibt es aber â€œparaâ€
â†’ para = kurz fÃ¼r Paragraph  <br><br>
      
      <b>9. FLOWS UND STACKS</b><br><br>

Flows und Stacks sind Boxen, Ã¤hnlich wie â€œ
undâ€ in HTML.
Stacks kann man sich wie zusammengebundene Dominosteine vorstellen. Legt man mehr Dominosteine auf einen Stapel, so wird der Stapel einfach hÃ¶her.
Ein Flow dagegen ist eher wie eine Streichholzschachtel. FÃ¼llt man mehr StreichhÃ¶lzer hinein quetschen sich die HÃ¶lzchen einfach zusammen, damit sie irgendwie in die Schachtel passen. Auch in einer Streichholzschachtel kann der untergeordnete Teil â€œhÃ¶herâ€ werden, aber davor ordnen sich die StreichhÃ¶lzer nebeneinander an.
â†’ Das Hauptfenster das mit â€œShoes.appâ€ geÃ¶ffnet wird, ist ein Flow. Man kann auch fÃ¼r Flows und Stacks eine HÃ¶he und Breite festgelegt werden. Ein Beispiel dafÃ¼r kÃ¶nnte so aussehen:
Shoes.app do
stack width: 1.0, height: 1.0
do
background blue
end
end  <br><br>
      
      <b> 10. ZEICHNEN MIT SHOES</b><br><br>

Das Shoes Fenster kann man sich als Koordinatensystem mit einer x- und einer y-Achse vorstellen.
Dabei stellt die Ecke oben links den Nullpunkt dar.
Mit dem Befehl â€œleftâ€ wird immer die x-Achse angesprochen. Umso hÃ¶her der left-Wert umso weiter rechts befindet sich das Element.
Mit â€œtopâ€ kÃ¶nnen die Elemente auf der y-Achse verschoben werden. Umso hÃ¶her der top-Wert, desto tiefer rutscht das Element. <br><br>
      <b> 11. INTERAKTION MIT DEM NUTZER EINBAUEN</b><br><br>

      <b>BUTTONS</b><br>

Eine der am hÃ¤ufigsten genutzten Interaktionen mit dem Nutzer ist ein Button:
Shoes.app do
button â€œWas macht Shoes?â€ do
alert â€œalles farbig und beweglichâ€
end
end<br>
â†’ â€œbuttonâ€ bedeutet: jetzt kommt ein Button<br>
â†’ in den Hochkommata steht, was auf dem Button geschrieben sein soll<br>
â†’ was zwischen dem do und dem end steht, ist das was passieren soll, wenn auf den Button geklickt wird<br> <br>
      <b> 12. FAZIT</b><br><br>

Programmieren war bis zu diesem Semester etwas ganz Unbekanntes fÃ¼r mich. Nie hÃ¤tte ich gedacht, dass ich auch nur ansatzweise in BerÃ¼hrung damit kommen wÃ¼rde, und es Ã¼berhaupt kapieren wÃ¼rde. Wo ich jetzt aber am Ende des Kurses angelangt bin, muss ich sagen, dass ich es eigentlich sogar sehr interessant fand. Ich hatte meine HÃ¶hen und Tiefen, die Erfolgserlebnisse wenn etwas funktioniert hat, waren immer sehr schÃ¶n, aber ehrlich gesagt denke ich, dass die Frustration doch sehr hoch war. Oft haben Aufgaben nicht funktioniert, da sie im Ruby Kurs falsch dargestellt wurden, oder weil der Editor im Kurs nicht funktionierte. Dies fand ich echt schade, da ich deshalb oft schnell an mir selber gezweifelt habe, und dem Aufgeben immer sehr Nahe war. Zum GlÃ¼ck habe ich aber eine gewisse Menge an Ehrgeiz in mir, dass ich immer so lange an Aufgaben dran saÃŸ, bis ich sie endlich â€“ mit oder ohne Hilfe von anderen â€“ schaffen konnte.
Das Prinzip vom Flipped Classroom hat mir persÃ¶nlich nicht so zugesagt, da man, wenn man den Kurs einmal nicht rechtzeitig gemacht hat, nur sehr schwer mitgekommen ist. Dennoch haben mir die PrÃ¤senztermine immer etwas gebracht, da auch oft Ã¤ltere Themen wiederholt wurden.
Im GroÃŸen und Ganzen kann ich sagen, dass ich meine Ruby ProgrammierfÃ¤higkeiten als gut einstufen wÃ¼rde, was fÃ¼r mich persÃ¶nlich als Neuling, eine tolle Erfahrung ist!<br><br>
      
      
      <h2 class="Fundamentale Ideen der Informatik">Fundamentale Ideen der Informatik</h2>
      <p class="Fundamentale Ideen der Informatik">1. FUNDAMENTALE IDEEN UND BEGRIFFSERKLÃ„RUNG <br>
Fundamentale Ideen sind die grundlegenden Prinzipien, Denkweisen und Methoden der Informatik.
Man unterscheidet hierbei verschiedene Kriterien.</p>
        
        
      <h1 class="Schwerpunkte">Schwerpunkte</h1>
      <p class="Schwerpunkte">Unter diesem Reiter finden Sie meine beiden Schwerpunkte zu den Vorlesungen â€Programmieren in einer objektorientierten Umgebungâ€œ und â€Fundamentale Ideen der Informatikâ€. Viel SpaÃŸ beim DurchstÃ¶bern! ğŸ™‚</p>
      
      <h2 class="Programmieren in einer objektorientierten Umgebung â€“ Schwerpunkt">Programmieren in einer objektorientierten Umgebung â€“ Schwerpunkt</h2> 
    <p class="Programmieren in einer objektorientierten Umgebung â€“ Schwerpunkt">EINFÃœHRUNG <br>
Ich habe zusammen mit meiner Gruppe, mit Sophia Pournaras, Stefan Maisch und Tim Reisenauer, das Spiel â€œHero Troubleâ€ entwickelt. Unser Spiel basiert auf dem bereits vorhandenem Spiel â€œTank Troubleâ€ (https://www.tanktrouble.com), in dem es darum geht den bzw die gegnerischen Panzer abzuschieÃŸen. Dabei befinden sich die einzelnen Panzer an verschiedenen Stellen in einem Labyrinth. Es ist mÃ¶glich dieses Spiel alleine gegen einen Computer, zu zweit oder zu dritt zu spielen. </p>
    
      
      <h2 class="Fundamentale Ideen der Informatik â€“ Schwerpunkt">Fundamentale Ideen der Informatik â€“ Schwerpunkt</h2>
      <p class="Fundamentale Ideen der Informatik â€“ Schwerpunkt">EINFÃœHRUNG VERSCHLÃœSSELUNG: <br>

Unter VerschlÃ¼sselung versteht man Verfahren und Algorithmen, die Daten mittels digitaler bzw. elektronischer Codes oder SchlÃ¼ssel inhaltlich in eine nicht lesbare Form umwandeln. Diesen Vorgang bezeichnet man als VerschlÃ¼sseln. Gleichzeitig wird dafÃ¼r gesorgt, dass nur mit dem Wissen eines SchlÃ¼ssels die geheimen Daten wieder entschlÃ¼sselt werden kÃ¶nnen.
Anstatt von VerschlÃ¼sselung spricht man auch von Chiffrierung, was das gleiche meint.

 </p>
      </div>
    
    
    

<!-- Cmap Bereich -->

  <div id="cmap" class="svg">
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1173px" height="596px" style="background-color:#ffffff;">

        <!-- Connection Lines -->
            <g>
                <path d="M469 68L428 101" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M410 115L377 139" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M528 68L580 107" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M598 121L624 141" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M330 175L305 194" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M286 208L258 228" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M370 175L391 197" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M404 211L420 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M634 177L617 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M607 214L597 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M673 177L706 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M725 214L747 231" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
        
        <!-- Linking Phrases -->
            <g>
                <g>
                    <text x="387px" y="113px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="557px" y="119px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="264px" y="206px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="366px" y="209px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="587px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="684px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
        
        <!-- Concepts -->
            <g>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="460px" y="54px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="16pt" font-family="Verdana">
                        <tspan>Thema</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="291px" y="165px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="585px" y="167px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="185px" y="252px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="389px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="538px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>3</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="723px" y="255px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>4</tspan>
                    </text>
                </g>
            </g>
        </svg>
  </div>
   
  <script type="text/javascript" src="navigation.js"></script>
</body>
</html>

