<html lang:"de"="">
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css" type="text/css">
    <title>IT3 E-Portfolio</title>
    
  </head>
<!-- Body Bereich -->     
<body>
  <div id="inhalt" class="inhalt">
    <h1 class="Vorlesungen">Vorlesungen</h1>
    <p class="Vorlesungen">Unter diesem Reiter finden Sie meine beiden Zusammenfassungen zu den Vorlesungen ‚ÄûProgrammieren in einer objektorientierten Umgebung‚Äú und ‚ÄûFundamentale Ideen der Informatik‚Äû. Viel Spa√ü beim Durchst√∂bern!üôÇ</p>
     
      <h2 class="Programmieren in einer objektorientierten Umgebung">Programmieren in einer objektorientierten Umgebung</h2>
      <p class="Programmieren in einer objektorientierten Umgebung"> <b>1. EINF√úHRUNG IN RUBY</b> <br> <br>
Ruby wurde zwei Jahre lang von Yukihiro Matsumoto entwickelt, und im Jahr 1995 ver√∂ffentlicht. Bis dahin war Ruby eine vollkommen unbekannte Sprache. 2004 wurde das Webframework Ruby on Rails ver√∂ffentlicht, und Rubys Durchbruch erfolgte. Heute geh√∂rt Ruby zu den am meist verbreiteten Programmiersprachen der Welt.
Ruby ist eine sogenannte interpretierte Skriptsprache. Das bedeutet, ein Ruby-Programm wird vom Ruby-Interpreter ge√∂ffnet, Zeile f√ºr Zeile gelesen und die Ruby-Anweisungen in Maschinensprache √ºbersetzt. Um also ein Ruby-Programm ausf√ºhren zu k√∂nnen, muss auf dem Rechner ein entsprechender Interpreter installiert sein.
Ruby ist au√üerdem eine objektorientierte Sprache, was hei√üt, dass jeder Wert ein Objekt ist, und jedes Objekt zu einer Klasse geh√∂rt.</p>
      <br> 
      <b> WARUM RUBY?</b> <br>
Ruby ist eine freie Programmiersprache, das hei√üt also, dass diese kostenlos, frei zu benutzen, zu kopieren, zu ver√§ndern und zu verbreiten ist. Au√üerdem bietet Ruby einen guten Einstieg in die Programmierung, da es relativ einfach zu lernen ist. Die Befehle k√∂nnen dazu auch besser verstanden werden, da sie an der englischen Sprache orientiert sein. Dazu unterst√ºtzt Ruby die neuesten, wichtigen Programmiermethodiken: Objektorientierung, XP, und auch mehrere Programmierparadigmen. Ein weiterer sehr wichtiger Aspekt ist, dass Ruby der menschlichen Denkweise sehr √§hnelt. <br> <br>
<b> EXKURS </b> <br> <br>
 ASSEMBLER<br>
‚Üí f√ºr den Menschen lesbare Sprache <br>
‚Üí Umwandlung in Maschinensprache notwendig <br>
‚Üí zu umst√§ndlich und fehleranf√§llig <br> <br>
      COMPILER<br>
‚Üí √ºbersetzt das in Hochsprache formulierte Programm in Maschinensprache, das dann ausgef√ºhrt werden kann <br> <br>
      INTERPRETER <br>
‚Üí analysiert das in Hochsprache formulierte Programm und aktiviert direkt die entsprechenden Maschinenbefehle <br> <br>
      <b>ALGORITHMEN UND PROGRAMME</b> <br>
Algorithmen sind genau definierte Handlungsvorschriften die zur L√∂sung eines Problems dienen. Ein daf√ºr allt√§gliches Beispiel sind Kochrezepte, in welchem beschrieben wird, in welcher Reihenfolge Schritte zu erledigen sind.
Programme sind konkrete Formen von Algorithmen. Diese bestehen aus mehreren Anweisungen, die dann vom Computer interpretiert, und in der Reihenfolge durchgef√ºhrt werden. <br> <br>
      <b>ERSTE ANWEISUNGEN</b> <br>
√úblicherweise wird eine einfache Anweisung in eine Zeile geschrieben. Diese orientiere sich an der nat√ºrlichen, also englischen Sprache.<br>
puts ‚Äì es erfolgt eine Ausgabe mit Zeilenumbruch <br>
print ‚Äì es erfolgt eine Ausgabe ohne Zeilenumbruch <br>
Raute (#) ‚Äì hierbei handelt es sich um einen Kommentar; die Raute und alles das in der Zeile danach steht wird vom Ruby-Interpreter ignoriert <br>
#=> ‚Äì eine Raute mit einem darauffolgenden Pfeil zeigt an, welcher Wert bei dem Code herauskommen w√ºrde, wenn man ihn ausf√ºhren w√ºrde <br> <br>
      <b>2. DATENTYPEN UND VARIABLEN </b> <br> <br>

      <b> DATENTYPEN </b> <br>
Daten, ihre Ausf√ºhrung und Manipulation bilden die Basis von Computerprogrammen. In Ruby sind folgende, einfache und komplexe Datentypen vordefiniert: <br><br>

      <b>EINFACHE DATENTYPEN</b> <br>

Zahlen: ‚Ä¶werden in Ruby meist wie im realen Leben eingesetzt; zum Rechnen, als Index, etc. Unterschieden wird zwischen ganzzahligen Werten (Integer wie 1; -1; 1000) und Flie√ükommazahlen (Float wie 1.2; 3.06; -6.66) <br>

Zeichen: ‚Ä¶ist ein einzelner Buchstabe, Ziffer, Leerzeichen oder sonstiges typografisches Symbol. <br>

Zeichenketten (String): ‚Ä¶eine Kette von Zeichen (Buchstaben, Zahlen etc.) umschlossen von einfachen oder doppelten Anf√ºhrungszeichen <br>

String-Interpolation ‚Äì Besonderheit:Strings in doppelten Anf√ºhrungszeichen k√∂nnen beliebige Ruby-Ausdr√ºcke beinhalten. 

Wenn der String erzeugt wird, wird der Ausdruck ausgewertet, in einen String konvertiert und anstelle des Ausdrucks selbst in die Zeichenkette eingef√ºgt.

Ausdr√ºcke innerhalb eines Strings beginnen mit dem Raute-Zeichen (#) und werden von geschweiften Klammern ({ }) umschlossen:

puts ‚Äû1 + 2 = #{1+2}‚Äú #=> 1 + 2 = 3

Boolean / Boolsche Werte: ‚Ä¶logische Aussage, kann wahr (true), falsch (false) oder leer (nil) sein

In manchen F√§llen ist eine Umwandlung der Datentypen notwendig. Ein Beispiel finden Sie in der ersten √úbung zu diesem Kapitel. Hierf√ºr gibt es folgende Befehle:<br><br>

      <b>UMWANDLUNG DER DATENTYPEN</b> <br>
      to_s ‚Äì Umwandlung zu einem String
      to_i ‚Äì Umwandlung zu einem Integer
      .to_f ‚Äì Umwandlung zu einem Float <br> <br>

      <b> VARIABLEN</b> <br>

Variablen haben in Programmiersprachen eine wichtige Rolle. Sie erleichtern einem das Nutzen und Schreiben von Programmen. Wird einer Variable einmal ein Wert zugeordnet, kann dieser beliebig oft genutzt und aufgerufen werden.
Variablen kann man sich wie ein Gef√§√ü vorstellen, in dem ein Wert hinterlegt wird. Variablen k√∂nnen anhand von beliebigen Datentypen hinterlegt werden. Egal ob String, Boolean, oder einfach nur eine Zahl.
Es wird weiter unterschieden zwischen lokalen und globalen Variablen.
Lokale Variablen werden entweder durch einen Unterstrich oder einen Kleinbuchstaben zu Beginn der Variable gekennzeichnet. Sie gelten f√ºr die Methode, f√ºr die sie definiert werden. Wenn aber eine Methode bereits eine Variable verwendet, greift sie auf diese zur√ºck, und erstellt keine neue.
Globale Variablen werden mit einem $ gekennzeichnet. Diese sind immer und √ºberall im Ruby Programm sichtbar. Es gibt auch globale Variablen, die keinen zugewiesenen Wert haben, besitzen dann automatisch den Wert nil. <br> <br>
      <b> LITERALE UND AUSDR√úCKE</b> <br><br>

      <b>LITERALE</b> <br>

Um bestimmte Ausdr√ºcke zu erzeugen, gibt es eine Art Kurzsyntax, die Literale. Einfach ausgedr√ºckt sind Literale Abfolgen von Ziffern und Zahlen.
‚Äòein String Literal‚Äô <br> <br>
      <b>AUSDR√úCKE</b><br>
Ein Ausdruck ist ein St√ºck Code, der vom Ruby-Interpreter ausgewertet wird, um einen Wert zu erzeugen. Prim√§rausdr√ºcke sind die einfachsten m√∂glichen Ausdr√ºcke, die nicht aus einfacheren Ausdr√ºcken zusammengesetzt sind. Dazu geh√∂ren Literale, Referenzen auf Variablen und Aufrufe von Methoden.
Es k√∂nnen ebenfalls gr√∂√üere Ausdr√ºcke erzeugt werden. Dies erfolgt indem man Prim√§rausdr√ºcke durch Operatoren kombiniert werden. <br> <br>
      <b>3. ANWEISUNGEN UND FUNKTIONEN</b><br><br>

      <b>OPERATOREN</b> <br>

Ein Ausdruck wird √ºblicherweise aus Werten und Operatoren gebildet. Hierbei gibt es unter anderem die arithmetischen Operatoren, Zuweisungsoperatoren oder logischen Operatoren.<br> <br>
      <b> FUNKTIONEN</b><br>
Funktionen sind Codebl√∂cke, die einmal definiert werden und auf die dann beliebig oft zur√ºckgegriffen werden kann. So l√§sst sich ein Programm besser strukturieren und der Code kompakt halten.
Die zwei Schl√ºsselw√∂rter f√ºr Definitionen sind def und end. Man beginnt mit ‚Äúdef‚Äù, woraufhin der Funktionsname und optionale ein oder mehrere Parameter in Klammern folgen.
Im Funktionsrumpf befindet sich der Ruby-Code, der bei Aufruf der Funktion ausgef√ºhrt wird. Die Parameter werden hier wie normale Variablen verwendet. Das Ende wird dann mit ‚Äúend‚Äù gekennzeichnet.
Allgemein formuliert sieht dies dann so aus:
def name (parameter)
Funktionsrumpf
‚Ä¶
‚Ä¶
end <br> <br>
      <b>4. KONTROLLSTRUKTUREN</b> <br><br>

Kontrollstrukturen dienen dazu den geradlinigen Programmfluss zu unterbrechen und an anderen Stellen zu verzweigen. Dies geschieht in Form von Fallentscheidungen oder Schleifen.<br><br>

      <b>FALLENTSCHEIDUNGEN</b><br>

Das wichtige bei Fallentscheidungen ist, dass sie immer mindestens eine, oder mehrere Bedingungen enthalten. Je nach dem ob die Bedingung erf√ºllt ist, oder nicht, wird ein bestimmtes St√ºck Code ausgef√ºhrt.<br>

‚Üí Es handelt sich hierbei also um Bool‚Äôsche Ausdr√ºcke. Anweisungen werden dann ausgef√ºhrt, je nach dem, ob eine Bedingung true oder false ist.<br><br>

      <b>SCHLEIFEN</b><br>
Schleifen bewirken, dass ein Code-St√ºck wiederholt und somit mehrmals ausgef√ºhrt wird.<br><br>
      
      <b>  ITERATOREN</b> <br>

Eine Alternative Wiederholungen zu erzeugen, wird durch Iteratoren geboten. Ein Iterator schreitet durch eine Liste von Elementen und arbeitet diese Element f√ºr Element ab. Unter anderem gibt es die numerischen Iteratoren times, upto und downto.
Die Methode times ruft ihren zugeh√∂rigen Codeblock genau n-mal auf. (Sie geht also durch eine Liste aufeinanderfolgender Zahlen mit n Elementen beginnend bei 0. Dies kann so aussehen:
3.times do
print ‚Äúhaha!‚Äù
end
# => haha!haha!haha!
Wird die Methode durch einen formalen Parameter erweitert, so zeigt dieser den Wert der aktuellen Iteration an und √ºbergibt ihn dem Codeblock:
3.times do |x|
print x
end
# => 012
Die Methode upto ruft ihren zugeh√∂rigen Block einmal f√ºr jeden Wert auf, der zwischen dem Integer, f√ºr den sie aufgerufen wird und dem Integer, der als Argument √ºbergeben wird, liegt:
3.upto(5) do |x|
print x
end
# => 345
Die Methode downto funktioniert im Prinzip wie upto, nur anders herum, das hei√üt sie iteriert von der gr√∂√üeren zur kleineren Zahl:
5.downto(3) do |x|
print x
end
# => 543
Durch die Methode step kann eine ver√§nderte Schrittweite angegeben werden. Sie wird wie upto f√ºr einen Startwert aufgerufen, als Argumente werden ebenfalls der Endwert und zus√§tzlich die Schrittweiter √ºbergeben:
3.step(5, 0.5) do |x|
print x
print ‚Äú;‚Äù
end
# => 3.0;3.5;4.0;4.5;5.0 <br> <br>
      
     <b> CODEBL√ñCKE </b><br>

Die Verwendung von Bl√∂cken ist eine der Grundlagen der Verwendung von Iteratoren. Der Code zwischen do und end wird als Codeblock oder anonyme Funktion bezeichnet.

Ein Block kann nicht f√ºr sich allein stehen, sondern muss auf den Aufruf einer Methode folgen, der ihn ausf√ºhrt, wie es z.B. bei Iterationen der Fall ist.

Bl√∂cke werden durch geschweifte Klammern oder die Schl√ºsselw√∂rter do und end umschlossen.{} bzw. do m√ºssen sich dabei in der gleichen Zeile befinden wie der Methodenaufruf.

Der R√ºckgabewert eines Blocks ist, wie auch bei Funktionen, der Wert des letzten Ausdrucks, der in dem Block ausgewertet wurde.

F√ºr die Namensr√§ume von Variablen gilt:<br>

‚Üí lokale Variablen, die innerhalb des Codeblocks erzeugt werden, sind au√üerhalb nicht verf√ºgbar<br>

‚Üí existiert eine lokale Variable bereits au√üerhalb der Funktion, kann sie innerhalb verwendet werden, d.h. es wird keine neue Variable erzeugt<br> <br>

         <b>5. ARRAYS UND HASHES</b> <br><br>

         <b> ARRAYS</b><br>

Ein Array ist eine Liste mit mehreren Elementen. Die L√§nge eines Arrays ist dynamisch, das hei√üt also, dass diese bei Bedarf mitw√§chst.
Ein Array wird erzeugt, indem es mit einem Namen versehen wird, dem entweder [] oder Array.new zugewiesen wird:
liste = [ ]
liste = Array.new <br>
‚Üí in diesen beiden F√§llen ist das Array zun√§chst leer<br>
‚Üí soll es mit einer bestimmten L√§nge erzeugt werden, wird beim Aufruf ‚ÄúArray.new‚Äù in <br>
Klammern eine Zahl √ºbergeben:<br>
liste = Array.new(3)
Einem Array k√∂nnen auch direkt bei der Erstellung konkrete Werte √ºbergeben werden:
liste = [1,4,5,6,8]
liste = Array.new(3,‚ÄùHallo‚Äù)
# => [‚ÄúHallo‚Äù, ‚ÄúHallo‚Äù, ‚ÄúHallo‚Äù] <br><br>

         <b>ZUGRIFF</b><br>

Der Zugriff auf einen bestimmten Wert im Array funktioniert √ºber den Namen des Arrays und der Angabe der gew√ºnschten Stelle (dem Index) in eckigen Klammern:
liste = [2]
# => [5]
Es kann auch auf einen Teil, d.h. auf mehrere Werte im Array zugegriffen werden. Hierbei wird die erste und letzte Stelle im Array angegeben, auf deren Werte zugegriffen werden soll:
liste = [2..4]
# => [5,6,8] (also Zugriff auf die Werte an den Stellen 2 bis 4 im Array)
Au√üerdem kann ein Wert innerhalb des Arrays ersetzt werden:
liste[2] = 100
# => [1,4,100,6,8]
Bei negativen Indexzahlen erfolgt der Zugriff von hinten:
liste[-1] = [1,4,5,6,8]
# => [8] <br> <br>

         <b>METHODEN</b><br>

‚Üí die L√§nge von Arrays ist dynamisch und kann dementsprechend ver√§ndert werden:<br>
myArray.insert(stelle, wert)<br>
‚Üí f√ºgt an der angegebenen Stelle ein neues Element ein und alle folgenden Elemente werden um eine Stelle nach hinten verschoben<br>
Beispielsweise so:
liste.insert(3, 10)
# => [1, 4, 100, 10, 6, 8]
myArray.delete(wert)
‚Üí ebenso k√∂nnen bestimmte Werte im Array gel√∂scht werden, was dann so aussieht:
liste.delete(4)
# => [1, 100, 10, 6, 8]<br>
‚Üí unter der Seite http://ruby-doc.org/core-2.5.0/Array.html findet man noch ganze viele andere Methoden, die man f√ºr Arrays anwenden kann!  <br> <br>   
       
         <b>  SORTIEREN</b><br>

Eine h√§ufig auftretende Aufgabe in der Programmierung ist das Sortieren von Elementen innerhalb des Arrays. Hierf√ºr wird unter anderem das Bubble-Sort Prinzip verwendet. Das Prinzip dabei ist, immer zwei nebeneinander liegende Elemente zu vergleichen und ggf. zu vertauschen.
Nebenstehend soll eine Reihe von Zahlen der Gr√∂√üe nach geordnet werden (Gr√∂√ütes nach rechts, Kleinstes nach links).
Jeweils zwei nebeneinander liegende Zahlen werden verglichen und die gr√∂√üere der beiden nach rechts verschoben.
Somit gelangt in einem Durchlauf die gr√∂√üte Zahl ganz nach rechts. Im n√§chsten die zweitgr√∂√üte Zahl an die zweite Stelle von rechts, usw.
Um die Reihe also vollst√§ndig zu sortieren, werden n-1 Durchg√§nge ben√∂tigt.
Um nun konkret Werte in einem Array zu sortieren, wird √ºber die Indexzahl auf die einzelnen Werte zugegriffen und diese miteinander verglichen. Um alle Werte zu erfassen, erfolgt dies in einer Schleife. Das hei√üt bei ersten Schleifendurchlauf wird der Wert an der Stelle 0 mit dem Wert an Stelle 1 vergleichen. Im n√§chsten Durchlauf wird dann der Wert an Stelle 1 mit dem an Stelle 2 verglichen usw. Je nachdem, was ein Vergleich ergibt, werden die Werte an den Stellen vertauscht.<br> <br>
      
         <b>HASHES</b><br>

Ein Hash ist, wie ein Array, eine Menge von Werten. Anders als im Array sind diese allerdings nicht geordnet, sondern werden √ºber einen Schl√ºssel identifiziert. Das hei√üt f√ºr jeden Schl√ºssel ist ein bestimmer Wert hinterlegt:
grauwerte = {‚Äúweiss‚Äù=>255, ‚Äúhellgrau‚Äù=> 100, ‚Äúschwarz‚Äù=> 0}
Der Zugriff auf diese Werte erfolgt ebenfalls √ºber den Schl√ºssel:
grauwerte[‚Äúhellgrau‚Äù]
# => 100 <br> <br>

         <b>6. TEST-DRIVEN-DEVELOPMENT</b><br><br>

Test-Driven-Development bezeichnet eine Methode des Programmentwurfs bei der ein Programm schrittweise, begleitet von kontinuierlichem Testen entwickelt wird.   
         ‚Üí d. h. ein Teil des Programms wird entworfen, dann getestet und verbessert bis es keine Fehler mehr gibt <br>
‚Üí dann wird das Programm erweitert, getestet, erweitert, getestet, und so weiter<br>
‚Üí so sollen Fehler m√∂glichst fr√ºh erkannt und gel√∂st werden<br>
Folgendes ist ein Beispiel daf√ºr:
Es soll eine neue Funktion erstellt werden, die testet, ob es sich bei einer Jahreszahl um ein Schaltjahr handelt.
Es gilt:<br>
‚Äì ist die Zahl durch 4 teilbar, ist das Jahr ein Schaltjahr<br>
‚Äì ist die Zahl durch 4 und durch 100 teilbar, ist das Jahr kein Schaltjahr<br>
‚Äì ist die Zahl durch 4, 100 und 400 teilbar, ist das Jahr ein Schaltjahr<br>
Um die Funktion schrittweise zu entwickeln, wird nun zuerst ein Test erstellt:<br>
def assert( expression )
raise ‚ÄúFehler!‚Äù unless expression
end<br>
Der Test gibt eine Fehlermeldung aus, wenn der Ausdruck, f√ºr den er durchgef√ºhrt wird, nicht wahr ist.<br>
‚Üí Nun geht es darum, das Programm schrittweise zu entwickeln und zwischendurch immer wieder zu testen.<br> <br>
      
      <b>7. OBJEKTORIENTIERUNG</b><br> <br>

Ruby ist eine objektorientierte Programmiersprache. Dies bedeutet, dass in einem Ruby-Programm Ideen umgesetzt und damit gearbeitet werden kann, wie man es auch im realen Leben tun w√ºrde.
So werden in einem Programm Klassen und Objekte erstellt, f√ºr die beliebige Eigenschaften und Beziehungen untereinander definiert werden k√∂nnen. Klassen sind sozusagen Vorlagen aus denen dann konkrete Objekte erzeugt werden. Innerhalb der Klasse k√∂nnen eine Reihe von Eigenschaften und Methoden definiert werden, die auf ein Objekt angewendet werden k√∂nnen.
Zur Veranschaulichung, hier ein Beispiel:<br>
‚Üí es wird als erstes die Klasse ‚ÄúCat‚Äù erstellt<br>
class Cat
attr_accessor :name, :age, :color
end
Der Name einer Klasse beginnt immer mit einem Gro√übuchstaben.
atrr_accessor definiert Instanzvariablen, das hei√üt Variablen, durch die Objekte der Klasse identifiziert werden k√∂nnen.
‚Üí hier kann eine Instanz der Klasse Cat durch Name, Alter und Farbe identifiziert werden
‚Üí aus dieser Klasse k√∂nnen nun Objekte erzeugt werden:
cat_instance = Cat.new
F√ºr das erzeugt Objekt k√∂nnen im n√§chsten Schritt Attribute definiert werden:
cat_instance.name =‚ÄùMax‚Äù
cat_instance.age = 3
cat_instance.color = ‚Äúblack‚Äù
‚Üí jetzt erzeuge ich eine neue Klasse Snake:
class = Snake
attr_accessor :name, :age, :color
end
! ein wichtiges Merkmal objektorientierter Sprachen ist die Vererbung ‚Üí somit ist es m√∂glich, f√ºr die Klassen ‚ÄúCat‚Äù und ‚ÄúSnake‚Äù eine Superklasse ‚ÄúPet‚Äù zu erzeugen ‚Üí ‚ÄúCat‚Äù und ‚ÄúSnake‚Äù bilden also die Subklassen von ‚ÄúPet‚Äù und erben damit alle Eigenschaften, die f√ºr die Klasse ‚ÄúPet‚Äù zur Verf√ºgung stehen
‚Üí also wird die Klasse ‚ÄúPet‚Äù zun√§chst definiert
class Pet
attr_accessor :name, :age, :color
end
‚Üí jetzt werden die Subklassen definiert, dabei gibt ‚Äú<Pet‚Äù die Vererbung der Klasse Pet an
‚Üí somit m√ºssen Attribute, die f√ºr ‚ÄúPet‚Äù gelten, f√ºr ‚ÄúCat‚Äù und ‚ÄúSnake‚Äù nicht noch einmal definiert werden
class Cat < Pet
end
class Snake < Pet
end
‚Üí es k√∂nnen allerdings aber auch spezifische Eigenschaften f√ºr einzelne Klassen hinzugef√ºgt werden
class Snake < Pet
attr_accessor :length
end
‚Üí au√üerdem k√∂nnen bestimmte Methoden definiert werden, d. h. Anweisungen, die f√ºr Objekte der Klasse verwendet werden k√∂nnen
class Dog < Pet
def bark
puts ‚ÄúWoof!‚Äù
end
end
‚Üí wird nun ein neuer Hund erstellt, kann f√ºr diesen die Methode ‚Äúbark‚Äù aufgerufen werden
a_dog = Dog.new
a_dog.bark
# => Woof!  <br><br>
      
      <b>8. SHOES UND RUBY</b>br>

 Shoes ist ein GUI-Framework f√ºr Ruby. GUI steht f√ºr ‚Äûgraphical user interface‚Äú und ist eine grafische Benutzeroberfl√§che, mit denen User in Programmen interagieren k√∂nnen. Framework bedeutet ‚ÄûGer√ºst‚Äú und man kann es als Vorprogrammierung verstehen. So sind in Shoes schon Funktionen und Elemente vorhanden und m√ºssen nicht jedes Mal neu programmiert werden. Shoes kann auf verschiedene Weise verwendet und eingebunden werden. Shoes erm√∂glicht es also, f√ºr Ruby Programme eine graphische Benutzeroberfl√§che zu erstellen. Somit kann der Nutzer einfach mit einem Spiel/einer Webseite oder √§hnlichem interagieren.
Shoes.app do
‚Ä¶
‚Ä¶
end
bildet das Grundger√ºst im Ruby Programm
‚Üí wird etwas nach dem ‚Äúend‚Äù geschrieben, wird es zwar in Ruby ausgef√ºhrt, in Shoes aber nicht<br><br>

      <b>ERSTE SHOES ANWENDUNG</b>br>

‚Üí Textausgaben √ºber puts und print sind nicht mehr m√∂glich, anstatt davon gibt es aber ‚Äúpara‚Äù
‚Üí para = kurz f√ºr Paragraph  <br><br>
      
      <b>10. FLOWS UND STACKS</b><br>

Flows und Stacks sind Boxen, √§hnlich wie ‚Äú
und‚Äù in HTML.
Stacks kann man sich wie zusammengebundene Dominosteine vorstellen. Legt man mehr Dominosteine auf einen Stapel, so wird der Stapel einfach h√∂her.
Ein Flow dagegen ist eher wie eine Streichholzschachtel. F√ºllt man mehr Streichh√∂lzer hinein quetschen sich die H√∂lzchen einfach zusammen, damit sie irgendwie in die Schachtel passen. Auch in einer Streichholzschachtel kann der untergeordnete Teil ‚Äúh√∂her‚Äù werden, aber davor ordnen sich die Streichh√∂lzer nebeneinander an.
‚Üí Das Hauptfenster das mit ‚ÄúShoes.app‚Äù ge√∂ffnet wird, ist ein Flow. Man kann auch f√ºr Flows und Stacks eine H√∂he und Breite festgelegt werden. Ein Beispiel daf√ºr k√∂nnte so aussehen:
Shoes.app do
stack width: 1.0, height: 1.0
do
background blue
end
end  <br><br>
      
      <b> 11. ZEICHNEN MIT SHOES</b><br><br>

Das Shoes Fenster kann man sich als Koordinatensystem mit einer x- und einer y-Achse vorstellen.
Dabei stellt die Ecke oben links den Nullpunkt dar.
Mit dem Befehl ‚Äúleft‚Äù wird immer die x-Achse angesprochen. Umso h√∂her der left-Wert umso weiter rechts befindet sich das Element.
Mit ‚Äútop‚Äù k√∂nnen die Elemente auf der y-Achse verschoben werden. Umso h√∂her der top-Wert, desto tiefer rutscht das Element. <br><br>
      <b> 12. INTERAKTIONEN MIT DEM NUTZER EINBAUEN</b><br><br>

      <b>BUTTONS</b><br>

Eine der am h√§ufigsten genutzten Interaktionen mit dem Nutzer ist ein Button:
Shoes.app do
button ‚ÄúWas macht Shoes?‚Äù do
alert ‚Äúalles farbig und beweglich‚Äù
end
end<br>
‚Üí ‚Äúbutton‚Äù bedeutet: jetzt kommt ein Button<br>
‚Üí in den Hochkommata steht, was auf dem Button geschrieben sein soll<br>
‚Üí was zwischen dem do und dem end steht, ist das was passieren soll, wenn auf den Button geklickt wird<br> <br>
      <b> 13. FAZIT</b><br><br>

Programmieren war bis zu diesem Semester etwas ganz Unbekanntes f√ºr mich. Nie h√§tte ich gedacht, dass ich auch nur ansatzweise in Ber√ºhrung damit kommen w√ºrde, und es √ºberhaupt kapieren w√ºrde. Wo ich jetzt aber am Ende des Kurses angelangt bin, muss ich sagen, dass ich es eigentlich sogar sehr interessant fand. Ich hatte meine H√∂hen und Tiefen, die Erfolgserlebnisse wenn etwas funktioniert hat, waren immer sehr sch√∂n, aber ehrlich gesagt denke ich, dass die Frustration doch sehr hoch war. Oft haben Aufgaben nicht funktioniert, da sie im Ruby Kurs falsch dargestellt wurden, oder weil der Editor im Kurs nicht funktionierte. Dies fand ich echt schade, da ich deshalb oft schnell an mir selber gezweifelt habe, und dem Aufgeben immer sehr Nahe war. Zum Gl√ºck habe ich aber eine gewisse Menge an Ehrgeiz in mir, dass ich immer so lange an Aufgaben dran sa√ü, bis ich sie endlich ‚Äì mit oder ohne Hilfe von anderen ‚Äì schaffen konnte.
Das Prinzip vom Flipped Classroom hat mir pers√∂nlich nicht so zugesagt, da man, wenn man den Kurs einmal nicht rechtzeitig gemacht hat, nur sehr schwer mitgekommen ist. Dennoch haben mir die Pr√§senztermine immer etwas gebracht, da auch oft √§ltere Themen wiederholt wurden.
Im Gro√üen und Ganzen kann ich sagen, dass ich meine Ruby Programmierf√§higkeiten als gut einstufen w√ºrde, was f√ºr mich pers√∂nlich als Neuling, eine tolle Erfahrung ist!
      
      
      <h2 class="Fundamentale Ideen der Informatik">Fundamentale Ideen der Informatik</h2>
      <p class="Fundamentale Ideen der Informatik">1. FUNDAMENTALE IDEEN UND BEGRIFFSERKL√ÑRUNG <br>
Fundamentale Ideen sind die grundlegenden Prinzipien, Denkweisen und Methoden der Informatik.
Man unterscheidet hierbei verschiedene Kriterien.</p>
        
        
      <h1 class="Schwerpunkte">Schwerpunkte</h1>
      <p class="Schwerpunkte">Unter diesem Reiter finden Sie meine beiden Schwerpunkte zu den Vorlesungen ‚ÄûProgrammieren in einer objektorientierten Umgebung‚Äú und ‚ÄûFundamentale Ideen der Informatik‚Äû. Viel Spa√ü beim Durchst√∂bern! üôÇ</p>
      
      <h2 class="Programmieren in einer objektorientierten Umgebung ‚Äì Schwerpunkt">Programmieren in einer objektorientierten Umgebung ‚Äì Schwerpunkt</h2> 
    <p class="Programmieren in einer objektorientierten Umgebung ‚Äì Schwerpunkt">EINF√úHRUNG <br>
Ich habe zusammen mit meiner Gruppe, mit Sophia Pournaras, Stefan Maisch und Tim Reisenauer, das Spiel ‚ÄúHero Trouble‚Äù entwickelt. Unser Spiel basiert auf dem bereits vorhandenem Spiel ‚ÄúTank Trouble‚Äù (https://www.tanktrouble.com), in dem es darum geht den bzw die gegnerischen Panzer abzuschie√üen. Dabei befinden sich die einzelnen Panzer an verschiedenen Stellen in einem Labyrinth. Es ist m√∂glich dieses Spiel alleine gegen einen Computer, zu zweit oder zu dritt zu spielen. </p>
    
      
      <h2 class="Fundamentale Ideen der Informatik ‚Äì Schwerpunkt">Fundamentale Ideen der Informatik ‚Äì Schwerpunkt</h2>
      <p class="Fundamentale Ideen der Informatik ‚Äì Schwerpunkt">EINF√úHRUNG VERSCHL√úSSELUNG: <br>

Unter Verschl√ºsselung versteht man Verfahren und Algorithmen, die Daten mittels digitaler bzw. elektronischer Codes oder Schl√ºssel inhaltlich in eine nicht lesbare Form umwandeln. Diesen Vorgang bezeichnet man als Verschl√ºsseln. Gleichzeitig wird daf√ºr gesorgt, dass nur mit dem Wissen eines Schl√ºssels die geheimen Daten wieder entschl√ºsselt werden k√∂nnen.
Anstatt von Verschl√ºsselung spricht man auch von Chiffrierung, was das gleiche meint.

 </p>
      </div>
    
    
    

<!-- Cmap Bereich -->

  <div id="cmap" class="svg">
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1173px" height="596px" style="background-color:#ffffff;">

        <!-- Connection Lines -->
            <g>
                <path d="M469 68L428 101" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M410 115L377 139" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M528 68L580 107" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M598 121L624 141" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M330 175L305 194" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M286 208L258 228" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M370 175L391 197" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M404 211L420 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M634 177L617 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M607 214L597 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M673 177L706 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M725 214L747 231" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
        
        <!-- Linking Phrases -->
            <g>
                <g>
                    <text x="387px" y="113px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="557px" y="119px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="264px" y="206px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="366px" y="209px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="587px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="684px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
        
        <!-- Concepts -->
            <g>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="460px" y="54px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="16pt" font-family="Verdana">
                        <tspan>Thema</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="291px" y="165px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="585px" y="167px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="185px" y="252px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="389px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="538px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>3</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="723px" y="255px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>4</tspan>
                    </text>
                </g>
            </g>
        </svg>
  </div>
   
  <script type="text/javascript" src="navigation.js"></script>
</body>
</html>

