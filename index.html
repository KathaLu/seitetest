<html lang:"de"="">
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css" type="text/css">
    <title>IT3 E-Portfolio</title>
    
  </head>
<!-- Body Bereich -->     
<body>
  <div id="inhalt" class="inhalt">
    <h1 class="Vorlesungen">Vorlesungen</h1>
    <p class="Vorlesungen">Unter diesem Reiter finden Sie meine beiden Zusammenfassungen zu den Vorlesungen ‚ÄûProgrammieren in einer objektorientierten Umgebung‚Äú und ‚ÄûFundamentale Ideen der Informatik‚Äû. Viel Spa√ü beim Durchst√∂bern!üôÇ</p>
     
      <h2 class="Programmieren in einer objektorientierten Umgebung">Programmieren in einer objektorientierten Umgebung</h2>
      <p class="Programmieren in einer objektorientierten Umgebung"> <b>1. EINF√úHRUNG IN RUBY</b> <br> <br>
Ruby wurde zwei Jahre lang von Yukihiro Matsumoto entwickelt, und im Jahr 1995 ver√∂ffentlicht. Bis dahin war Ruby eine vollkommen unbekannte Sprache. 2004 wurde das Webframework Ruby on Rails ver√∂ffentlicht, und Rubys Durchbruch erfolgte. Heute geh√∂rt Ruby zu den am meist verbreiteten Programmiersprachen der Welt.
Ruby ist eine sogenannte interpretierte Skriptsprache. Das bedeutet, ein Ruby-Programm wird vom Ruby-Interpreter ge√∂ffnet, Zeile f√ºr Zeile gelesen und die Ruby-Anweisungen in Maschinensprache √ºbersetzt. Um also ein Ruby-Programm ausf√ºhren zu k√∂nnen, muss auf dem Rechner ein entsprechender Interpreter installiert sein.
Ruby ist au√üerdem eine objektorientierte Sprache, was hei√üt, dass jeder Wert ein Objekt ist, und jedes Objekt zu einer Klasse geh√∂rt.</p>
      <br> 
      <b> WARUM RUBY?</b> <br>
Ruby ist eine freie Programmiersprache, das hei√üt also, dass diese kostenlos, frei zu benutzen, zu kopieren, zu ver√§ndern und zu verbreiten ist. Au√üerdem bietet Ruby einen guten Einstieg in die Programmierung, da es relativ einfach zu lernen ist. Die Befehle k√∂nnen dazu auch besser verstanden werden, da sie an der englischen Sprache orientiert sein. Dazu unterst√ºtzt Ruby die neuesten, wichtigen Programmiermethodiken: Objektorientierung, XP, und auch mehrere Programmierparadigmen. Ein weiterer sehr wichtiger Aspekt ist, dass Ruby der menschlichen Denkweise sehr √§hnelt. <br> <br>
<b> EXKURS </b> <br> <br>
 ASSEMBLER<br>
‚Üí f√ºr den Menschen lesbare Sprache <br>
‚Üí Umwandlung in Maschinensprache notwendig <br>
‚Üí zu umst√§ndlich und fehleranf√§llig <br> <br>
      COMPILER<br>
‚Üí √ºbersetzt das in Hochsprache formulierte Programm in Maschinensprache, das dann ausgef√ºhrt werden kann <br> <br>
      INTERPRETER <br>
‚Üí analysiert das in Hochsprache formulierte Programm und aktiviert direkt die entsprechenden Maschinenbefehle <br> <br>
      <b>ALGORITHMEN UND PROGRAMME</b> <br>
Algorithmen sind genau definierte Handlungsvorschriften die zur L√∂sung eines Problems dienen. Ein daf√ºr allt√§gliches Beispiel sind Kochrezepte, in welchem beschrieben wird, in welcher Reihenfolge Schritte zu erledigen sind.
Programme sind konkrete Formen von Algorithmen. Diese bestehen aus mehreren Anweisungen, die dann vom Computer interpretiert, und in der Reihenfolge durchgef√ºhrt werden. <br> <br>
      <b>ERSTE ANWEISUNGEN</b> <br>
√úblicherweise wird eine einfache Anweisung in eine Zeile geschrieben. Diese orientiere sich an der nat√ºrlichen, also englischen Sprache.<br>
puts ‚Äì es erfolgt eine Ausgabe mit Zeilenumbruch <br>
print ‚Äì es erfolgt eine Ausgabe ohne Zeilenumbruch <br>
Raute (#) ‚Äì hierbei handelt es sich um einen Kommentar; die Raute und alles das in der Zeile danach steht wird vom Ruby-Interpreter ignoriert <br>
#=> ‚Äì eine Raute mit einem darauffolgenden Pfeil zeigt an, welcher Wert bei dem Code herauskommen w√ºrde, wenn man ihn ausf√ºhren w√ºrde <br> <br>
      <b>2. DATENTYPEN UND VARIABLEN </b> <br> <br>

      <b> DATENTYPEN </b> <br>
Daten, ihre Ausf√ºhrung und Manipulation bilden die Basis von Computerprogrammen. In Ruby sind folgende, einfache und komplexe Datentypen vordefiniert: <br><br>

      <b>EINFACHE DATENTYPEN</b> <br>

Zahlen: ‚Ä¶werden in Ruby meist wie im realen Leben eingesetzt; zum Rechnen, als Index, etc. Unterschieden wird zwischen ganzzahligen Werten (Integer wie 1; -1; 1000) und Flie√ükommazahlen (Float wie 1.2; 3.06; -6.66) <br>

Zeichen: ‚Ä¶ist ein einzelner Buchstabe, Ziffer, Leerzeichen oder sonstiges typografisches Symbol. <br>

Zeichenketten (String): ‚Ä¶eine Kette von Zeichen (Buchstaben, Zahlen etc.) umschlossen von einfachen oder doppelten Anf√ºhrungszeichen <br>

String-Interpolation ‚Äì Besonderheit:Strings in doppelten Anf√ºhrungszeichen k√∂nnen beliebige Ruby-Ausdr√ºcke beinhalten. 

Wenn der String erzeugt wird, wird der Ausdruck ausgewertet, in einen String konvertiert und anstelle des Ausdrucks selbst in die Zeichenkette eingef√ºgt.

Ausdr√ºcke innerhalb eines Strings beginnen mit dem Raute-Zeichen (#) und werden von geschweiften Klammern ({ }) umschlossen:

puts ‚Äû1 + 2 = #{1+2}‚Äú #=> 1 + 2 = 3

Boolean / Boolsche Werte: ‚Ä¶logische Aussage, kann wahr (true), falsch (false) oder leer (nil) sein

In manchen F√§llen ist eine Umwandlung der Datentypen notwendig. Ein Beispiel finden Sie in der ersten √úbung zu diesem Kapitel. Hierf√ºr gibt es folgende Befehle:<br><br>

      <b>UMWANDLUNG DER DATENTYPEN</b> <br>
      to_s ‚Äì Umwandlung zu einem String
      to_i ‚Äì Umwandlung zu einem Integer
      .to_f ‚Äì Umwandlung zu einem Float <br> <br>

      <b> VARIABLEN</b> <br>

Variablen haben in Programmiersprachen eine wichtige Rolle. Sie erleichtern einem das Nutzen und Schreiben von Programmen. Wird einer Variable einmal ein Wert zugeordnet, kann dieser beliebig oft genutzt und aufgerufen werden.
Variablen kann man sich wie ein Gef√§√ü vorstellen, in dem ein Wert hinterlegt wird. Variablen k√∂nnen anhand von beliebigen Datentypen hinterlegt werden. Egal ob String, Boolean, oder einfach nur eine Zahl.
Es wird weiter unterschieden zwischen lokalen und globalen Variablen.
Lokale Variablen werden entweder durch einen Unterstrich oder einen Kleinbuchstaben zu Beginn der Variable gekennzeichnet. Sie gelten f√ºr die Methode, f√ºr die sie definiert werden. Wenn aber eine Methode bereits eine Variable verwendet, greift sie auf diese zur√ºck, und erstellt keine neue.
Globale Variablen werden mit einem $ gekennzeichnet. Diese sind immer und √ºberall im Ruby Programm sichtbar. Es gibt auch globale Variablen, die keinen zugewiesenen Wert haben, besitzen dann automatisch den Wert nil. <br> <br>
      <b> LITERALE UND AUSDR√úCKE</b> <br><br>

      <b>LITERALE</b> <br>

Um bestimmte Ausdr√ºcke zu erzeugen, gibt es eine Art Kurzsyntax, die Literale. Einfach ausgedr√ºckt sind Literale Abfolgen von Ziffern und Zahlen.
‚Äòein String Literal‚Äô <br> <br>
      <b>AUSDR√úCKE</b><br>
Ein Ausdruck ist ein St√ºck Code, der vom Ruby-Interpreter ausgewertet wird, um einen Wert zu erzeugen. Prim√§rausdr√ºcke sind die einfachsten m√∂glichen Ausdr√ºcke, die nicht aus einfacheren Ausdr√ºcken zusammengesetzt sind. Dazu geh√∂ren Literale, Referenzen auf Variablen und Aufrufe von Methoden.
Es k√∂nnen ebenfalls gr√∂√üere Ausdr√ºcke erzeugt werden. Dies erfolgt indem man Prim√§rausdr√ºcke durch Operatoren kombiniert werden. <br> <br>
      <b>3. ANWEISUNGEN UND FUNKTIONEN</b><br><br>

      <b>OPERATOREN</b> <br>

Ein Ausdruck wird √ºblicherweise aus Werten und Operatoren gebildet. Hierbei gibt es unter anderem die arithmetischen Operatoren, Zuweisungsoperatoren oder logischen Operatoren.<br> <br>
      <b> FUNKTIONEN</b><br>
Funktionen sind Codebl√∂cke, die einmal definiert werden und auf die dann beliebig oft zur√ºckgegriffen werden kann. So l√§sst sich ein Programm besser strukturieren und der Code kompakt halten.
Die zwei Schl√ºsselw√∂rter f√ºr Definitionen sind def und end. Man beginnt mit ‚Äúdef‚Äù, woraufhin der Funktionsname und optionale ein oder mehrere Parameter in Klammern folgen.
Im Funktionsrumpf befindet sich der Ruby-Code, der bei Aufruf der Funktion ausgef√ºhrt wird. Die Parameter werden hier wie normale Variablen verwendet. Das Ende wird dann mit ‚Äúend‚Äù gekennzeichnet.
Allgemein formuliert sieht dies dann so aus:
def name (parameter)
Funktionsrumpf
‚Ä¶
‚Ä¶
end <br> <br>
      <b>4. KONTROLLSTRUKTUREN</b> <br><br>

Kontrollstrukturen dienen dazu den geradlinigen Programmfluss zu unterbrechen und an anderen Stellen zu verzweigen. Dies geschieht in Form von Fallentscheidungen oder Schleifen.<br><br>

      <b>FALLENTSCHEIDUNGEN</b><br>

Das wichtige bei Fallentscheidungen ist, dass sie immer mindestens eine, oder mehrere Bedingungen enthalten. Je nach dem ob die Bedingung erf√ºllt ist, oder nicht, wird ein bestimmtes St√ºck Code ausgef√ºhrt.<br>

‚Üí Es handelt sich hierbei also um Bool‚Äôsche Ausdr√ºcke. Anweisungen werden dann ausgef√ºhrt, je nach dem, ob eine Bedingung true oder false ist.<br><br>

      <b>SCHLEIFEN</b><br>
Schleifen bewirken, dass ein Code-St√ºck wiederholt und somit mehrmals ausgef√ºhrt wird.<br><br>
      
      <b>  ITERATOREN</b> <br>

Eine Alternative Wiederholungen zu erzeugen, wird durch Iteratoren geboten. Ein Iterator schreitet durch eine Liste von Elementen und arbeitet diese Element f√ºr Element ab. Unter anderem gibt es die numerischen Iteratoren times, upto und downto.
Die Methode times ruft ihren zugeh√∂rigen Codeblock genau n-mal auf. (Sie geht also durch eine Liste aufeinanderfolgender Zahlen mit n Elementen beginnend bei 0. Dies kann so aussehen:
3.times do
print ‚Äúhaha!‚Äù
end
# => haha!haha!haha!
Wird die Methode durch einen formalen Parameter erweitert, so zeigt dieser den Wert der aktuellen Iteration an und √ºbergibt ihn dem Codeblock:
3.times do |x|
print x
end
# => 012
Die Methode upto ruft ihren zugeh√∂rigen Block einmal f√ºr jeden Wert auf, der zwischen dem Integer, f√ºr den sie aufgerufen wird und dem Integer, der als Argument √ºbergeben wird, liegt:
3.upto(5) do |x|
print x
end
# => 345
Die Methode downto funktioniert im Prinzip wie upto, nur anders herum, das hei√üt sie iteriert von der gr√∂√üeren zur kleineren Zahl:
5.downto(3) do |x|
print x
end
# => 543
Durch die Methode step kann eine ver√§nderte Schrittweite angegeben werden. Sie wird wie upto f√ºr einen Startwert aufgerufen, als Argumente werden ebenfalls der Endwert und zus√§tzlich die Schrittweiter √ºbergeben:
3.step(5, 0.5) do |x|
print x
print ‚Äú;‚Äù
end
# => 3.0;3.5;4.0;4.5;5.0 <br> <br>
      
     <b> CODEBL√ñCKE </b><br>

Die Verwendung von Bl√∂cken ist eine der Grundlagen der Verwendung von Iteratoren. Der Code zwischen do und end wird als Codeblock oder anonyme Funktion bezeichnet.

Ein Block kann nicht f√ºr sich allein stehen, sondern muss auf den Aufruf einer Methode folgen, der ihn ausf√ºhrt, wie es z.B. bei Iterationen der Fall ist.

Bl√∂cke werden durch geschweifte Klammern oder die Schl√ºsselw√∂rter do und end umschlossen.{} bzw. do m√ºssen sich dabei in der gleichen Zeile befinden wie der Methodenaufruf.

Der R√ºckgabewert eines Blocks ist, wie auch bei Funktionen, der Wert des letzten Ausdrucks, der in dem Block ausgewertet wurde.

F√ºr die Namensr√§ume von Variablen gilt:<br>

‚Üí lokale Variablen, die innerhalb des Codeblocks erzeugt werden, sind au√üerhalb nicht verf√ºgbar<br>

‚Üí existiert eine lokale Variable bereits au√üerhalb der Funktion, kann sie innerhalb verwendet werden, d.h. es wird keine neue Variable erzeugt<br> <br>

         <b>5. ARRAYS UND HASHES</b> <br><br>

         <b> ARRAYS</b><br>

Ein Array ist eine Liste mit mehreren Elementen. Die L√§nge eines Arrays ist dynamisch, das hei√üt also, dass diese bei Bedarf mitw√§chst.
Ein Array wird erzeugt, indem es mit einem Namen versehen wird, dem entweder [] oder Array.new zugewiesen wird:
liste = [ ]
liste = Array.new <br>
‚Üí in diesen beiden F√§llen ist das Array zun√§chst leer<br>
‚Üí soll es mit einer bestimmten L√§nge erzeugt werden, wird beim Aufruf ‚ÄúArray.new‚Äù in <br>
Klammern eine Zahl √ºbergeben:<br>
liste = Array.new(3)
Einem Array k√∂nnen auch direkt bei der Erstellung konkrete Werte √ºbergeben werden:
liste = [1,4,5,6,8]
liste = Array.new(3,‚ÄùHallo‚Äù)
# => [‚ÄúHallo‚Äù, ‚ÄúHallo‚Äù, ‚ÄúHallo‚Äù] <br><br>

         <b>ZUGRIFF</b><br>

Der Zugriff auf einen bestimmten Wert im Array funktioniert √ºber den Namen des Arrays und der Angabe der gew√ºnschten Stelle (dem Index) in eckigen Klammern:
liste = [2]
# => [5]
Es kann auch auf einen Teil, d.h. auf mehrere Werte im Array zugegriffen werden. Hierbei wird die erste und letzte Stelle im Array angegeben, auf deren Werte zugegriffen werden soll:
liste = [2..4]
# => [5,6,8] (also Zugriff auf die Werte an den Stellen 2 bis 4 im Array)
Au√üerdem kann ein Wert innerhalb des Arrays ersetzt werden:
liste[2] = 100
# => [1,4,100,6,8]
Bei negativen Indexzahlen erfolgt der Zugriff von hinten:
liste[-1] = [1,4,5,6,8]
# => [8] <br> <br>

         <b>METHODEN</b><br>

‚Üí die L√§nge von Arrays ist dynamisch und kann dementsprechend ver√§ndert werden:<br>
myArray.insert(stelle, wert)<br>
‚Üí f√ºgt an der angegebenen Stelle ein neues Element ein und alle folgenden Elemente werden um eine Stelle nach hinten verschoben<br>
Beispielsweise so:
liste.insert(3, 10)
# => [1, 4, 100, 10, 6, 8]
myArray.delete(wert)
‚Üí ebenso k√∂nnen bestimmte Werte im Array gel√∂scht werden, was dann so aussieht:
liste.delete(4)
# => [1, 100, 10, 6, 8]<br>
‚Üí unter der Seite http://ruby-doc.org/core-2.5.0/Array.html findet man noch ganze viele andere Methoden, die man f√ºr Arrays anwenden kann!  <br> <br>   
       
         <b>  SORTIEREN</b><br>

Eine h√§ufig auftretende Aufgabe in der Programmierung ist das Sortieren von Elementen innerhalb des Arrays. Hierf√ºr wird unter anderem das Bubble-Sort Prinzip verwendet. Das Prinzip dabei ist, immer zwei nebeneinander liegende Elemente zu vergleichen und ggf. zu vertauschen.
Nebenstehend soll eine Reihe von Zahlen der Gr√∂√üe nach geordnet werden (Gr√∂√ütes nach rechts, Kleinstes nach links).
Jeweils zwei nebeneinander liegende Zahlen werden verglichen und die gr√∂√üere der beiden nach rechts verschoben.
Somit gelangt in einem Durchlauf die gr√∂√üte Zahl ganz nach rechts. Im n√§chsten die zweitgr√∂√üte Zahl an die zweite Stelle von rechts, usw.
Um die Reihe also vollst√§ndig zu sortieren, werden n-1 Durchg√§nge ben√∂tigt.
Um nun konkret Werte in einem Array zu sortieren, wird √ºber die Indexzahl auf die einzelnen Werte zugegriffen und diese miteinander verglichen. Um alle Werte zu erfassen, erfolgt dies in einer Schleife. Das hei√üt bei ersten Schleifendurchlauf wird der Wert an der Stelle 0 mit dem Wert an Stelle 1 vergleichen. Im n√§chsten Durchlauf wird dann der Wert an Stelle 1 mit dem an Stelle 2 verglichen usw. Je nachdem, was ein Vergleich ergibt, werden die Werte an den Stellen vertauscht.<br> <br>
      
         <b>HASHES</b><br>

Ein Hash ist, wie ein Array, eine Menge von Werten. Anders als im Array sind diese allerdings nicht geordnet, sondern werden √ºber einen Schl√ºssel identifiziert. Das hei√üt f√ºr jeden Schl√ºssel ist ein bestimmer Wert hinterlegt:
grauwerte = {‚Äúweiss‚Äù=>255, ‚Äúhellgrau‚Äù=> 100, ‚Äúschwarz‚Äù=> 0}
Der Zugriff auf diese Werte erfolgt ebenfalls √ºber den Schl√ºssel:
grauwerte[‚Äúhellgrau‚Äù]
# => 100 <br> <br>

         <b>6. TEST-DRIVEN-DEVELOPMENT</b><br><br>

Test-Driven-Development bezeichnet eine Methode des Programmentwurfs bei der ein Programm schrittweise, begleitet von kontinuierlichem Testen entwickelt wird.   
         ‚Üí d. h. ein Teil des Programms wird entworfen, dann getestet und verbessert bis es keine Fehler mehr gibt <br>
‚Üí dann wird das Programm erweitert, getestet, erweitert, getestet, und so weiter<br>
‚Üí so sollen Fehler m√∂glichst fr√ºh erkannt und gel√∂st werden<br>
Folgendes ist ein Beispiel daf√ºr:
Es soll eine neue Funktion erstellt werden, die testet, ob es sich bei einer Jahreszahl um ein Schaltjahr handelt.
Es gilt:<br>
‚Äì ist die Zahl durch 4 teilbar, ist das Jahr ein Schaltjahr<br>
‚Äì ist die Zahl durch 4 und durch 100 teilbar, ist das Jahr kein Schaltjahr<br>
‚Äì ist die Zahl durch 4, 100 und 400 teilbar, ist das Jahr ein Schaltjahr<br>
Um die Funktion schrittweise zu entwickeln, wird nun zuerst ein Test erstellt:<br>
def assert( expression )
raise ‚ÄúFehler!‚Äù unless expression
end<br>
Der Test gibt eine Fehlermeldung aus, wenn der Ausdruck, f√ºr den er durchgef√ºhrt wird, nicht wahr ist.<br>
‚Üí Nun geht es darum, das Programm schrittweise zu entwickeln und zwischendurch immer wieder zu testen.<br> <br>
      
      <b>7. OBJEKTORIENTIERUNG</b><br> <br>

Ruby ist eine objektorientierte Programmiersprache. Dies bedeutet, dass in einem Ruby-Programm Ideen umgesetzt und damit gearbeitet werden kann, wie man es auch im realen Leben tun w√ºrde.
So werden in einem Programm Klassen und Objekte erstellt, f√ºr die beliebige Eigenschaften und Beziehungen untereinander definiert werden k√∂nnen. Klassen sind sozusagen Vorlagen aus denen dann konkrete Objekte erzeugt werden. Innerhalb der Klasse k√∂nnen eine Reihe von Eigenschaften und Methoden definiert werden, die auf ein Objekt angewendet werden k√∂nnen.
Zur Veranschaulichung, hier ein Beispiel:<br>
‚Üí es wird als erstes die Klasse ‚ÄúCat‚Äù erstellt<br>
class Cat
attr_accessor :name, :age, :color
end
Der Name einer Klasse beginnt immer mit einem Gro√übuchstaben.
atrr_accessor definiert Instanzvariablen, das hei√üt Variablen, durch die Objekte der Klasse identifiziert werden k√∂nnen.
‚Üí hier kann eine Instanz der Klasse Cat durch Name, Alter und Farbe identifiziert werden
‚Üí aus dieser Klasse k√∂nnen nun Objekte erzeugt werden:
cat_instance = Cat.new
F√ºr das erzeugt Objekt k√∂nnen im n√§chsten Schritt Attribute definiert werden:
cat_instance.name =‚ÄùMax‚Äù
cat_instance.age = 3
cat_instance.color = ‚Äúblack‚Äù
‚Üí jetzt erzeuge ich eine neue Klasse Snake:
class = Snake
attr_accessor :name, :age, :color
end
! ein wichtiges Merkmal objektorientierter Sprachen ist die Vererbung ‚Üí somit ist es m√∂glich, f√ºr die Klassen ‚ÄúCat‚Äù und ‚ÄúSnake‚Äù eine Superklasse ‚ÄúPet‚Äù zu erzeugen ‚Üí ‚ÄúCat‚Äù und ‚ÄúSnake‚Äù bilden also die Subklassen von ‚ÄúPet‚Äù und erben damit alle Eigenschaften, die f√ºr die Klasse ‚ÄúPet‚Äù zur Verf√ºgung stehen
‚Üí also wird die Klasse ‚ÄúPet‚Äù zun√§chst definiert
class Pet
attr_accessor :name, :age, :color
end
‚Üí jetzt werden die Subklassen definiert, dabei gibt ‚Äú<Pet‚Äù die Vererbung der Klasse Pet an
‚Üí somit m√ºssen Attribute, die f√ºr ‚ÄúPet‚Äù gelten, f√ºr ‚ÄúCat‚Äù und ‚ÄúSnake‚Äù nicht noch einmal definiert werden
class Cat < Pet
end
class Snake < Pet
end
‚Üí es k√∂nnen allerdings aber auch spezifische Eigenschaften f√ºr einzelne Klassen hinzugef√ºgt werden
class Snake < Pet
attr_accessor :length
end
‚Üí au√üerdem k√∂nnen bestimmte Methoden definiert werden, d. h. Anweisungen, die f√ºr Objekte der Klasse verwendet werden k√∂nnen
class Dog < Pet
def bark
puts ‚ÄúWoof!‚Äù
end
end
‚Üí wird nun ein neuer Hund erstellt, kann f√ºr diesen die Methode ‚Äúbark‚Äù aufgerufen werden
a_dog = Dog.new
a_dog.bark
# => Woof!  <br><br>
      
      <b>8. SHOES UND RUBY</b> <br> <br>

 Shoes ist ein GUI-Framework f√ºr Ruby. GUI steht f√ºr ‚Äûgraphical user interface‚Äú und ist eine grafische Benutzeroberfl√§che, mit denen User in Programmen interagieren k√∂nnen. Framework bedeutet ‚ÄûGer√ºst‚Äú und man kann es als Vorprogrammierung verstehen. So sind in Shoes schon Funktionen und Elemente vorhanden und m√ºssen nicht jedes Mal neu programmiert werden. Shoes kann auf verschiedene Weise verwendet und eingebunden werden. Shoes erm√∂glicht es also, f√ºr Ruby Programme eine graphische Benutzeroberfl√§che zu erstellen. Somit kann der Nutzer einfach mit einem Spiel/einer Webseite oder √§hnlichem interagieren.
Shoes.app do
‚Ä¶
‚Ä¶
end
bildet das Grundger√ºst im Ruby Programm
‚Üí wird etwas nach dem ‚Äúend‚Äù geschrieben, wird es zwar in Ruby ausgef√ºhrt, in Shoes aber nicht<br><br>

      <b>ERSTE SHOES ANWENDUNG</b><br>

‚Üí Textausgaben √ºber puts und print sind nicht mehr m√∂glich, anstatt davon gibt es aber ‚Äúpara‚Äù
‚Üí para = kurz f√ºr Paragraph  <br><br>
      
      <b>9. FLOWS UND STACKS</b><br><br>

Flows und Stacks sind Boxen, √§hnlich wie ‚Äú
und‚Äù in HTML.
Stacks kann man sich wie zusammengebundene Dominosteine vorstellen. Legt man mehr Dominosteine auf einen Stapel, so wird der Stapel einfach h√∂her.
Ein Flow dagegen ist eher wie eine Streichholzschachtel. F√ºllt man mehr Streichh√∂lzer hinein quetschen sich die H√∂lzchen einfach zusammen, damit sie irgendwie in die Schachtel passen. Auch in einer Streichholzschachtel kann der untergeordnete Teil ‚Äúh√∂her‚Äù werden, aber davor ordnen sich die Streichh√∂lzer nebeneinander an.
‚Üí Das Hauptfenster das mit ‚ÄúShoes.app‚Äù ge√∂ffnet wird, ist ein Flow. Man kann auch f√ºr Flows und Stacks eine H√∂he und Breite festgelegt werden. Ein Beispiel daf√ºr k√∂nnte so aussehen:
Shoes.app do
stack width: 1.0, height: 1.0
do
background blue
end
end  <br><br>
      
      <b> 10. ZEICHNEN MIT SHOES</b><br><br>

Das Shoes Fenster kann man sich als Koordinatensystem mit einer x- und einer y-Achse vorstellen.
Dabei stellt die Ecke oben links den Nullpunkt dar.
Mit dem Befehl ‚Äúleft‚Äù wird immer die x-Achse angesprochen. Umso h√∂her der left-Wert umso weiter rechts befindet sich das Element.
Mit ‚Äútop‚Äù k√∂nnen die Elemente auf der y-Achse verschoben werden. Umso h√∂her der top-Wert, desto tiefer rutscht das Element. <br><br>
      <b> 11. INTERAKTION MIT DEM NUTZER EINBAUEN</b><br><br>

      <b>BUTTONS</b><br>

Eine der am h√§ufigsten genutzten Interaktionen mit dem Nutzer ist ein Button:
Shoes.app do
button ‚ÄúWas macht Shoes?‚Äù do
alert ‚Äúalles farbig und beweglich‚Äù
end
end<br>
‚Üí ‚Äúbutton‚Äù bedeutet: jetzt kommt ein Button<br>
‚Üí in den Hochkommata steht, was auf dem Button geschrieben sein soll<br>
‚Üí was zwischen dem do und dem end steht, ist das was passieren soll, wenn auf den Button geklickt wird<br> <br>
      <b> 12. FAZIT</b><br><br>

Programmieren war bis zu diesem Semester etwas ganz Unbekanntes f√ºr mich. Nie h√§tte ich gedacht, dass ich auch nur ansatzweise in Ber√ºhrung damit kommen w√ºrde, und es √ºberhaupt kapieren w√ºrde. Wo ich jetzt aber am Ende des Kurses angelangt bin, muss ich sagen, dass ich es eigentlich sogar sehr interessant fand. Ich hatte meine H√∂hen und Tiefen, die Erfolgserlebnisse wenn etwas funktioniert hat, waren immer sehr sch√∂n, aber ehrlich gesagt denke ich, dass die Frustration doch sehr hoch war. Oft haben Aufgaben nicht funktioniert, da sie im Ruby Kurs falsch dargestellt wurden, oder weil der Editor im Kurs nicht funktionierte. Dies fand ich echt schade, da ich deshalb oft schnell an mir selber gezweifelt habe, und dem Aufgeben immer sehr Nahe war. Zum Gl√ºck habe ich aber eine gewisse Menge an Ehrgeiz in mir, dass ich immer so lange an Aufgaben dran sa√ü, bis ich sie endlich ‚Äì mit oder ohne Hilfe von anderen ‚Äì schaffen konnte.
Das Prinzip vom Flipped Classroom hat mir pers√∂nlich nicht so zugesagt, da man, wenn man den Kurs einmal nicht rechtzeitig gemacht hat, nur sehr schwer mitgekommen ist. Dennoch haben mir die Pr√§senztermine immer etwas gebracht, da auch oft √§ltere Themen wiederholt wurden.
Im Gro√üen und Ganzen kann ich sagen, dass ich meine Ruby Programmierf√§higkeiten als gut einstufen w√ºrde, was f√ºr mich pers√∂nlich als Neuling, eine tolle Erfahrung ist!<br><br>
         
      <h2 class="Fundamentale Ideen der Informatik">Fundamentale Ideen der Informatik</h2>
      <p class="Fundamentale Ideen der Informatik"> <b>1. FUNDAMENTALE IDEEN UND BEGRIFFSERKL√ÑRUNG</b> <br><br>
Fundamentale Ideen sind die grundlegenden Prinzipien, Denkweisen und Methoden der Informatik.
Man unterscheidet hierbei verschiedene Kriterien.</p>
Das Horizontalkriterium beschreibt, dass Fundamentale Ideen eine umfassende Anwendbarkeit in allen Bereichen besitzen, und eine Vielzahl von Ph√§nomenen ordnen und integrieren.     
Das Vertikalkriterium beschreibt, dass Fundamentale Ideen innerhalb eines Anwendungsbereiches auf jeder intellekturellen Ebene aufgezeigt werden. Die Unterschiede k√∂nnen dann in der Tiefe und Detaillierung ersichtlich werden. Ein Beispiel daf√ºr ist, dass Mathematik sowohl in der Schule, als auch in Universit√§ten gelehrt wird, aber auf unterschiedlichen Niveaus.
Das Zeitkriterium beschreibt, dass die Idee das Ergebnis einer lang andauernden Beobachtung einer Wissenschaft ist, und l√§ngerfristig relevant bleibt.
Das Sinnkriterium beschreibt, dass die Idee im Bezug zur allt√§glichen Sprache und Denken hat, und vortheoretisch unwissenschaftlich ist.<br><br>
      
      <b>Anwendungsbeispiel:</b><br>

‚ÄúIst das Bedienen einer Tastatur eine fundamentale Idee?‚Äù
Horizontal:
Ja, da man diese in mehreren Anwendungsbereichen verwenden kann ‚Äì bspw. im Internet, Spiele, Bearbeitungsprogramme, an unterschiedlichen Ger√§ten, etc.
Vertikal:
Ja, weil es egal von wem genutzt werden kann
Zeitkriterium:
Nein, da es auch schon alternative L√∂sungen zu Tastaturen, wie Sprachsteuerung, gibt.
Sinnkriterium:
Ja, aber dies kann sich in den kommenden Jahren auch √§ndern. <br><br>

      <b>EIN PROGRAMMABLAUF</b>
...ist die Verfolgung der Instruktionen eines Programms.<br>
‚Üí jede Instruktion kann Speicher lesen, Nebeneffekte haben (Peripherieger√§te, Speicher schreiben) und den Lauf beeinflussen (bedingt oder wiederholte Teile)<br><br>
   <b>INFORMATIONSPROZESSE</b><br>
Informationen sollen modelliert werden k√∂nnen
Mit Hilfe einer h√∂heren Programmiersprache
Frage: Wie werden diese Informationen repr√§sentiert und verarbeitet?
Werden visualisiert
Repr√§sentationen werden visuell dargestellt
Abl√§ufe werden als Animationen dargestellt <br><br>
 
<b>CODE DEBUGGEN</b> <br> 
Das Programm hat verschiedene Schnittstellen und Knoten
Wenn in einem Knoten ein Fehler vorliegt, dann kann oft der Rest nicht ausgef√ºhrt werden
√§hnlich wie bei Stromkreis
Jetzt muss man den Bug (engl. K√§fer) ‚âà Fehler finden
Dies kann geschehen, indem man den Fehler visuell darstellt
bei ruby: debug(‚ÄûHallo‚Äú)
Diesen Debug stellt man dann an den Knotenpunkt, wo der Fehler vorliegen k√∂nnte und testet ob das Programm an dieser Stelle l√§uft oder nicht <br><br>     
      
      <b>2. VERSIONIERUNG</b><br><br>
 ‚Üí Versionierung ist ein System, das erlaubt, mehrere Versionen einer Datei oder eines Verzeichnisses zu synchronisieren und von verschiedenen Devices darauf zuzugreifen und es zu bearbeiten.<br>
‚Üí Versionierung ist ein System, das paralleles Arbeiten an einer Datei oder an einem Verzeichnis erlaubt<br>
‚Üí Versionierung ist ein System, das mehrere Versionen synchronisiert<br>
‚Üí Versionierung ist ein System, das einen Arbeitsfluss zwischen mehreren Leuten erlaubt<br>
Beispiele hierf√ºr sind: GoogleDocs, Moodle, etc.<br> <br> 

      <b>WIESO BRAUCHT MAN VERSIONIERUNG?</b><br>
Situation
‚Üí Person A erstellt ein Dokument (Version 1) und schickt das beschriebene Dokument an Person B weiter.<br>
‚Üí Person B m√∂chte noch etwas ab√§ndern und f√ºgt noch einige weitere Informationen hinzu (Version 1.1) und schickt es dann an Person C weiter<br>
‚Üí Auch Person C √§ndert einige Dinge ab (Version 1.2)<br>
Problem<br>
‚Üí Person C muss die neuste Version (Version 1.2) jetzt an zwei verschiedene Personen weiterleiten<br>
‚Üí Person A und Person B wissen somit auch nicht, was Person C alles ver√§ndert hat<br>
‚Üí sehr schwieriges zusammenarbeiten<br>

L√∂sung<br>
‚Üí Prinzip der Versionierung: Jede Person hat die aktuelle Version als Kopie und kann somit alle √Ñnderungen der anderen personen mitverfolgen/sehen und somit direkt angezeigt bekommen, wer wann was ver√§ndert hat.<br><br>
      

      <b>VERSIONIERUNGSPROZESS </b><br>

1. Basic Checkins<br>
einfache Beitr√§ge werden hinzugef√ºgt
eine Datei wird st√§ndig ver√§ndert und gespeichert
f√ºr alle partizipierenden Personen sichtbar/bearbeitbar   <br><br>

      2. Checkout & Edit<br>
eine andere Person macht eine lokale Kopie<br>
√Ñnderungen werden an der Arbeitskopie vorgenommen und dann wieder eingecheckt<br>
er kann die Unterschiede berechnen (diffs) +Eggs +Soup<br>
Konflikte k√∂nnen auftreten <br>  <br>   
      
3. Branching<br>
unabh√§ngige Arbeiten k√∂nnen auf unterschiedlichen √Ñsten (branches) stattfinden
Im Server gibt es zwei unterschiedliche Reihen von Diffs  <br><br>
    
 4. Merging<br>
      zwei parallele Branches zusammen bringen (√Ñste werden wieder zusammengef√ºhrt) <br> <br>
      
      <b>VERTEILTE ODER ZENTRALE VERSIONIERUNG    </b><br> <br>
Zentrale Versionierung<br>
‚Üí altes Vorgehen <br>
‚Üí alle Commits sind auf einem Repository<br>
‚Üí Konsistenz gesichert, aber Konflikte und Datenverlust<br>br>
Vertikale Versionierung
‚Üí modernes Vorgehen<br>
‚Üí mehrere Repositories<br>
‚Üí jeder kann einen eigenen Server haben<br>
‚Üí Commits k√∂nnen erst auf lokalem Repository gemacht werden, erst sp√§ter wird dann ‚Äûgepullt‚Äú<br>
‚Üí Diffs (eigentlich Commits) sind Punkt-zu-Punkt vermittelt (Push, Pull)<br>
‚Üí wechselseitiger Zugriff auf Repositories<br>
‚Üí m√∂glich: Firmeninterner Austausch, eigene Branches, parallele Entwicklungen m√∂gich, vorherige Versionen k√∂nnen wiederhergestellt werden, aber Speicherplatzbedarf<br>
Versionierung: eine fundamentale Idee?<br>
Horizontal:<br>
‚Üí verschiedene Anwendungsfelder wie Grafik, Extranets, Entwicklung, Wikis‚Ä¶br>
Vertikal:<br>
‚Üí Kinder malen zusammen mit Kreiden am Boden<br>
‚Üí Studenten arbeiten an einem Word Dokument<br>
Zeit:<br>
‚Üí rcs und cvs seit den 90ern<br>
‚Üí GitHub als gro√üer Betreiber der Entwicklung<br>
GITHUB<br>
Kooperieren mit GitHub <br>
Git: Software zur Versionierungsverwaltung (von L Torvalds)
Code kann st√§ndig aktualisiert werden, den man bekommen hat
man kann auch vorherige Versionen √∂ffnen ‚Äî> speichert jede Art von Ver√§nderung
Entwickler reichen √Ñnderungen ein (durch Kommandozeile)
GitHub stellt diese √Ñnderungen ausf√ºhrlich auf zugeh√∂rigen Webseite dar
Alle Operationen durch das Git Programm
‚Üí Checkout, Commits, Push, Pull<br>

GitHub als Webanzeige<br>
‚Üí und als Editierungswerkzeug, Freies Login<br>
‚Üí Freie Verwendung solange es Open-Source bleibt<br>
Forken mit GitHub<br>
Forken (Aufgabelung): Entwicklungszweig nach der Aufspaltung eines Projekts in zwei oder mehrere Folgeprojekte
Jedes lesbare Repository (Ablage) kann geforkt werden<br>
In der Praxis:<br>
‚Üí registrieren<br>
‚Üí Repo finden, Fork Knopf<br>
‚Üí Checkout, Ver√§nderungen, Commit, Push<br>
‚Üí Pull Request<br><br>
      <b>Pull Request </b><br>
Feature, welches Entwickler nutzen, um die Zusammenarbeit zu erleichtern
bieten eine benutzerfreundliche Weboberfl√§che, um Code√§nderungen zu diskutieren, bevor sie ins offizielle Projekt integriert werden
Mechanismus, mit dem Entwickler Teammitglieder √ºber die Fertigstellung eines Features informieren kann
Sobald sein Feature-Branch soweit ist, setzt er √ºber seinen Bitbucket-Account ein Pull-Request ab ‚Üí alle Beteiligten wissen dann, dass der Code reviewt und in den Master-Branch gemergt werden muss<br><br>
 
      <b>3. BETRIEBSSYSTEME</b> <br><br>

      <b>Operating System (OS)</b><br>
Zusammenfassung von Computerprogrammen, welche die Systemressourcen eines Computers regeln
Darunter z√§hlen unter anderem Arbeitsspeicher, Festplatten und die Ein- und Ausgabeger√§te (Tastatur, Bildschirm)
Ein Betriebssystem verwaltet die genannten Punkte und stellt Anwendungsprogramme zur Verf√ºgung
Schnittstelle zwischen der Anwendungssoftware des Nutzers und der Hardware
verf√ºgen √ºber graphische Benutzeroberfl√§che (graphical user interface ‚Üí GUI)
ist auf der Festplatte abgelegt <br> <br>    
      
      <b>WIE MACHT MAN EIN PROGRAMM LAUFF√ÑHIG?</b><br>

Programmquellcode muss kompiliert werden
‚Üí Umwandlung von Programmcode in ausf√ºhrbaren Code
Laufumgebung (Compiler) interpretiert die Kompilierung
notwendig: Quellcode und ein Compiler<br><br>
      <b>IDEE EINER BIBLIOTHEK</b><br>
Application Programming Interface
Schnittstelle zur Anwendungsprogrammierung
arbeitet auf Quelltextebene anders als die Bin√§rschnittstellen (ABI)
Verst√§ndigung zwischen 2 Softwareprodukten ohne Eingabe von dem Anwender.
dient zur Anbindung an das Softwaresystem
Zugriff auf Datenbanken oder Hardware wie Festplatte/Graphikkarte
Ein St√ºck Programmcode, welches dazu dient, dass ein Programm automatisiert angesprochen werden kann<br><br>
 
      <b>API ERKL√ÑRT</b><br>

 https://www.youtube.com/watch?v=qW1qhb8r8xI<br><br>

      <b>VON NEUMANN ARCHITEKTUR</b><br>
Komponenten:<br>
CPU<br>
Rechenwerk (ALU = arithmetisch-logische Einheit)
‚Üí Das Rechenwerk f√ºhrt arithmetische und vergleichende Operationen aus und sorgt f√ºr den Transport von Operanden in den und aus dem Hauptspeicher.
Steuerwerk (CU = control unit)<br>
‚Üí Das Steuerwerk ermittelt zur Laufzeit die auszuf√ºhrende Befehlsfolge und sorgt f√ºr deren Ausf√ºhrung.<br>
E/A-Werk<br>
‚Üí steuert die Ein- und Ausgabe von Daten<br>
‚Üí Tastatur, Bildschirm<br>
Hauptspeicher
‚Üí besteht aus einer Folge von Speicherzellen, die sowohl Befehle als auch Operanden aufnehmen k√∂nnen<br>
‚Üí dient der Speicherung des aktuellen Programms, der √úbernahme von Eingabedaten, der √úbernahme von Daten aus einem externen Speicher und der vor√ºbergehenden Speicherung von Zwischen- oder Endergebnissen.
Bussystem<br>
‚Üí reduziert die Anzahl der ‚ÄûWege‚Äú, die zur Kommunikation der verschiedenen Komponenten n√∂tig sind, indem die Kommunikationen auf einem Datenweg zusammengeschlossen werden<br><br>
      
      <b>4. JAVA GRUNDLAGEN, KLASSEN UND OBJEKTE</b><br><br>

      <b>WAS IST INTELLIJ IDEA?</b><br>
‚Üí eine integrierte Entwicklungsumgebung f√ºr die Programmiersprache Java<br>
‚Üí entwickelt von dem Unternehmen namens JetBrains<br><br>

      <b>WAS IST JAVA?</b>br>
‚Üí eine Scriptsprache<br>
‚Üí eine objektorientierte Programmierung<br>
Voraussetzungen:<br>
‚Üí Java-Entwicklungswerkzeug (JDK) ‚Üí Erstellung von Java Programmen<br>
‚Üí Java-Laufteizumgebung (JRE)<br>
virtuelle Maschine (JVM) und Bibliotheken ‚Üí Ausf√ºhrung von Java Programmen<br>
Funktionsweise:<br>
‚Üí Quellcode in der Scriptsprache Java schreiben<br>
‚Üí Quellcode wird von Compiler in Bytecode umgewandelt (von Programmiersprache in Maschinensprache)<br>
‚Üí JVM (virtuelle Maschinen) werden eingesetzt ‚Üí interpretiert den Bytecode und f√ºhrt Programm aus<br>
‚Üí Je nach Betriebssystem, muss auch eine bestimmte virtuelle Maschine installiert sein, damit das Programm beliebig auf jedem Betriebssystem ausgef√ºhrt werden kann<br><br>

 <b>KLASSEN </b><br>
‚Üí strukturiert die Programme <br>
‚Üí besteht aus Attributen und Methoden<br>
‚Üí Verallgemeinerung von Objekten<br>
‚Üí beschreibt, was f√ºr Attribute ein Objekt haben kann, weist ihr aber keinen Wert zu<br>
‚Üí genauere Beschreibung und Wertzuweisung gibt es erst beim Objekt<br><br>
      <b>BEISPIEL</b><br>
Mensch mit Eigenschaften wie Augenfarbe, Geschlecht, Gr√∂√üe und Funktionen wie Sprechen, jedoch wei√ü man noch nicht welche Werte diese Eigenschaften haben<br><br>

      <b>OBJEKTE</b><br>
‚Üí genauere Beschreibung eines Dinges aus der Realit√§t<br>
‚Üí bestimmte Attribute (Eigenschaften), mit einem bestimmten Wert (der jeweiligen Klasse)<br>
‚Üí sind nicht immer greifbare Dinge, sondern auch Datenstrukturen<br>
‚Üí jedes Objekt ist einer Klasse zugeh√∂rig<br>
‚Üí Klasse Mensch kann viele Objekte haben ‚Üí 7,5 Milliarden Objekte insgesamt auf der Welt<br><br>

      <b>BEISPIEL </b>

Objekt = Amina Serdarevic
Augenfarbe = graublau
Haarfarbe = dunkelblond
Gr√∂√üe = 1,75 m
Geschlecht = weiblich
Sprache = bosnisch<br><br>

      <b>ATTRIBUTE</b><br>

‚Üí Eigenschaft eines Objekts einer Klasse<br>
‚Üí hat einen bestimmten Wert<br>
‚Üí Bsp. Geschlecht = weiblich<br><br>

      <b>SUBKLASSEN</b><br>

‚Üí ist eine Klasse, deren Objekte zu einer anderen Klasse geh√∂ren<br>
‚Üí alle Klassen sind Subklassen von Objekten, sie haben:<br>
‚Üí eine toString Methode, um in der Konsole gedruckt zu werden<br>
‚Üí eine equals Methode, um mit anderen verglichen zu werden<br><br>

      <b>METHODEN</b><br>

‚Üí werden mit einem Namen aufgerufen <br>
‚Üí kann einen Wert zur√ºckgeben<br>
‚Üí um Variablen zu isolieren, um Wiederholungen zu vermeiden<br>
‚Üí Interaktionene, die man an einem Objekt durchf√ºhren kann (z.B. sprechen), nennt man Methoden<br>
‚Üí Funktionen und Verhaltensweisen<br>
‚Üí greift auf Eigenschaften eines Objekts zu<br>
‚Üí Attribute k√∂nnen ver√§ndert werden, Attributwerte k√∂nnen abgefragt werden<br>
‚Üí Eigenschaften k√∂nnen auch zwei Zust√§nde haben (z.B. bei einem Lichtschalter an/aus)<br>
‚Üí durch Methoden kann abgefragt werden, ob eine bestimmte Eigenschaft zutrifft (true) oder nicht (false)<br>
‚Üí Methoden k√∂nnen:<br>
‚Äì private sein und sind nur in der Klasse sichtbar<br>
‚Äì protected sein und somit auch in den Subklassen und im Package sichtbar sein<br>
‚Äì default sein und damit im Package sichtbar<br>
‚Äì public sein und so von √ºberall erreichbar<br><br>

      <b>VARIABLEN</b><br>

‚Üí Beh√§lter f√ºr einen ver√§nderlichen Inhalt<br>
‚Üí Platzhalter f√ºr Daten<br>
‚Üí arithmetische Operationen (rechnen)<br>
‚Üí m√ºssen immer sinnvoll benannt werden (Codelesbarkeit)<br><br>

      <b>DATENTYPEN</b><br>
‚Üí bei jeder Deklaration einer Variable muss auch ihr Datentyp angegeben werden<br>
‚Üí variable wird erst deklariert anschlie√üend wird ein Wert zur√ºckgegeben<br>

int = tee;
tee = 250;Mit System.out.printIn(tee); kann die Variable ausgegeben werden
Anzeige: 250 <br><br>

      <b>5. SUCHMASCHINEN</b><br><br>
Eine Suchmaschine ist ein Programm zur Recherche von Dokumenten, die in einem Computer oder einem Computernetzwerk wie z. B. dem World Wide Web gespeichert sind. Internet-Suchmaschinen haben ihren Ursprung in Information-Retrieval-Systemen. Sie erstellen einen Schl√ºsselwort-Index f√ºr die Dokumentbasis, um Suchanfragen √ºber Schl√ºsselw√∂rter mit einer nach Relevanz geordneten Trefferliste zu beantworten. Nach Eingabe eines Suchbegriffs liefert eine Suchmaschine eine Liste von Verweisen auf m√∂glicherweise relevante Dokumente, meistens dargestellt mit Titel und einem kurzen Auszug des jeweiligen Dokuments. Dabei k√∂nnen verschiedene Suchverfahren Anwendung finden.<br><br>

      <b>AUFGABEN</b><br>
‚Üí Erstellen und Pflege von Datenstrukturen mit Informationen √ºber Dokumente<br>
‚Üí Verarbeiten von Suchanfragen<br>
‚Üí Aufbereitung der Ergebnisse (meist nach Relevanz sortiert) <br><br>
      
      
      <b>  6. DATENSTRUKTUREN</b><br><br>
Eine Datenstruktur ist ein Objekt zur Speicherung und Organisation von Daten. Es handelt sich um eine Struktur, weil die Daten in einer bestimmten Art und Weise angeordnet und verkn√ºpft werden, um den Zugriff auf sie und ihre Verwaltung effizient zu erm√∂glichen.
LINKED LIST <br>
‚Üí LinkedList (java.util.LinkedList), wird im Deutschen auch als Verkettete Liste bezeichnet<br>
‚Üí jedes Element hat einen Nachfolger links und einen rechts<br>
‚Üí Bei einer LinkedList stehen alle Listenelemente in Verbindung zum jeweiligen Vorg√§nger bzw. Nachfolger<br>
‚Üí Existiert kein Nachfolger, so verweist das letzte Element auf die null-Referenz.<br>
‚Üí Der Vorteil bei einer Verketteten Liste besteht darin, dass im Vergleich zu einer ArrayList die Elemente schneller hinzugef√ºgt und gel√∂scht werden k√∂nnen ‚Üí Verweise auf Nachbarn m√ºssen ge√§ndert werden<br>
‚Üí Element der Liste an einer bestimmten Stelle auslesen ‚Üí Zugriff langsamer, da Verbindungen bis zu passenden Element durchlaufen werden muss<br>
‚Üí Entscheidung f√ºr einen bestimmten Listen-Typ sollte von der Art und Anzahl der Zugriffe abh√§ngig gemacht werden<br>

Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking Search(77) for a sample animation on searching a value in a (Singly) Linked List.
Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs.<br><br>
      
      <b>7. PARALLELIT√ÑT</b><br><br>

‚Üí wenn mehrere Prozesse in einem Netzwerk oder Core laufen<br>
‚Üí Beispiel: Steam und Spotify laufen gleichzeitig<br>
Im Modell von Neumann gibt es keine Parallelit√§t mit Prozessoren. Ein Schedule also ein Ausf√ºhrungsplan ist f√ºr die vielen Durchf√ºhrungen zust√§ndig. Der Schedule gibt zudem noch an, in welcher Reihenfolge die Operationen stattfinden. Unteranderem geh√∂ren zu den Operationen Lese- und Schreiboperationen sowie Terminatorenoperationen. Desweiteren macht ein Schedule alle 50ms Unterbrechungen und f√§hrt anschlie√üend fort. Wir Nutzer merken dies nicht. Daher sind viele Betriebssysteme multitaskingf√§hig oder interleavingf√§hig. Interleaving ist eine Optimierungstechnik bei der Daten√ºbertragung. Dort werden Daten in einer bestimmten Reihenfolge geordnet, um einen h√∂heren Datensatz zu bekommen. <br><br>     
    
      <b>8. BENUTZERSCHNITTSTELLEN</b><br><br>

Die Benutzerschnittstelle ist die Stelle oder Handlung, mit der ein Mensch mit einer Maschine in Kontakt tritt. Im einfachsten Fall ist das ein Lichtschalter: Er geh√∂rt weder zum Menschen, noch zur ‚ÄûMaschine‚Äú (Lampe), sondern ist die Schnittstelle zwischen beiden.<br>
‚Üí auch Mensch-Maschine-Schnittstelle oder Human-Computer-Interaction genannt <br> <br>

      <b>BESTANDTEILE</b><br>

‚Üí Zugang zu Programmen und Dateien wird als Icon (Bildsymbole) dargestellt<br>
‚Üí Programme √∂ffnen ein Hauptfenster ‚Üí GUI-System erlaubt, solche Fenster in ihrer Gr√∂√üe und Position zu ver√§ndern, auszublenden oder auf die gesamte Bildschirmgr√∂√üe zu vergr√∂√üern<br>
‚Üí Weitere Bedienelemente: Schaltfl√§chen (Buttons), Toolbars (Symbolleisten, Werkzeugleisten), Schieberegler, Auswahllisten und Symbole<br>
‚Üí Zusammengefasst werden alle diese Elemente zum WIMP-Modell (engl. W f√ºr Windows (Fenster), I f√ºr Icons (Datei- und Programmsymbole), M f√ºr Menu (Men√º) und P f√ºr Pointer (Zeiger, der zum Beispiel durch die Maus bewegt wird))<br>
‚Üí Eine Palette als GUI-Element ist ‚Äûnicht-modal‚Äú und wird oft am Seitenrand angeordnet<br><br>      
      
      <b> 9. NETWORK</b> <br><br>

      <b>NETZWERK</b><br>

‚Üí Zusammenschluss von verschiedenen technischen Systemen ‚Üí erm√∂glicht Kommunikation der Systeme untereinander<br>
‚Üí Ziel: gemeinsame Nutzung von Ressourcen, wie bspw. Datenbanken, Drucker, Dateien oder Servern<br>
‚Üí die Kommunikation verl√§uft √ºber verschiedene Protokolle<br><br>

 <b>IDEE PACKET NETWORK </b><br>   
‚Üí ein Netzwerk aus verschiedenen Computern mit verschiedenen Adressen und Routern k√∂nnen miteinander kommunizieren<br>
‚Üí sie versenden sich gegenseitig verschiedene Datenpakete (Datenpaket ist eine Bezeichnung f√ºr in sich geschlossene Dateneinheiten)<br>
‚Üí sie besitzen einen Sender und einen Empf√§nger<br>
‚Üí das Meiste in einem Datenpaket besteht aus wichtigen Adressierungs- und
Verwaltungsinformationen, welche von IP-basierten Netzwerken die mit Quelladressen gef√ºllt sind an den richtigen Computer liefern<br>
‚Üí Solche Informationen befinden sich in einem Header (Header sind die Zusatzinformationen, die Nutzerdaten am Anfang eines Datenblocks erg√§nzen)<br><br>

      <b>SOCKETS</b><br>
‚Üí ein Socket ist ein Modul, welches als Kommunikationsendpunkt dient<br>
‚Üí Sockets werden verwendet, um Daten mit anderen Programmen auszutauschen<br>
‚Üí das Programm kann sich auf dem selben oder einem anderen Computer befinden<br>
‚Üí Sockets k√∂nnen Daten empfangen und versenden<br>
‚Üí sind daf√ºr zust√§ndig, dass Daten in der richtigen Reihenfolge versendet werden<br> <br>

      <b>BUFFER</b><br>

‚Üí Speicher f√ºr die Zwischenlagerung von Daten<br>
‚Üí die Daten, welche als erste da sind, werden zuerst empfangen, die anderen befinden sich sozusagen in einer ‚ÄúWarteschlange‚Äù<br>
‚Üí es k√∂nnen immer wieder Daten hinzukommen, die sich aber so lange in der Warteschlange befinden, bis sie empfangen werden<br><br>

      <b>10. VERSCHL√úSSELUNG</b><br><br>

Die Verschl√ºsselung ist eine M√∂glichkeit, die Sicherheit von Daten zu erh√∂hen, indem der Inhalt einer Nachricht oder Datei so unkenntlich gemacht wird, dass sie nur von der Person gelesen werden kann, die √ºber den passenden Verschl√ºsselungsschl√ºssel verf√ºgt.  
Die Grundidee der Verschl√ºsselung ist es, wie oben dargestellt wird, eine Nachricht von A nach B zu verschicken, ohne dass C die Nachricht sehen kann. So wie mit Postkarten, welche nicht ‚Äûverschl√ºsselt‚Äú sind und der ‚Äû3.‚Äú sie eventuell lesen kann, im Falle der Postkarte der Postbote. Durch Verschl√ºsselung wird dies verhindert. Um einen verschl√ºsselten Text zu lesen, muss man ‚Äûnur‚Äú den Schl√ºssel besitzen. Wenn man diesen hat, ist das L√∂sen der Verschl√ºsselung nicht mehr schwer. <br><br>     
      
      <b>  11. KOMPRIMIERUNG </b><br><br>

Die Datenkompression ‚Äì auch Datenkomprimierung genannt ‚Äì ist ein Vorgang, bei dem die Menge digitaler Daten verdichtet oder reduziert wird. Dadurch sinkt der ben√∂tigte Speicherplatz und die √úbertragungszeit der Daten verk√ºrzt sich.
Es werden zwei Arten von Komprimierung unterschieden, n√§mlich die verlustfreie und die verlustbehaftete Komprimierung.
Die verlustfreie Komprimierung kann zur√ºck in ihren Originalzustand gebracht werden, ist also reversibel.
Die verlustbehaftete Komprimierung hingegen kann nicht in ihren Originalzustand gebracht werden, da Daten verloren gehen. <br><br>
 <b>HUFFMAN CODIERUNG</b><br>
Die Huffman-Kodierung ist eine Form der Entropiekodierung, die 1952 von David A. Huffman entwickelt wurde um eine verlustlose Kompression zu erm√∂glichen.
Prinzip: Statt jedem Wort einen gleichlangen Code zuzuordnen, bekommen Zeichen, die h√§ufig im Text vorkommen einen k√ºrzeren Code als seltene Zeichen.
Hilfsmittel: Codeb√§ume, mit denen sich Codew√∂rter grafisch als Baum darstellen lassen. Den Code eines Zeichen liest man aus dem Codebaum ab, indem man von unten (also der Wurzel des Baumes) bis zum gesuchten Zeichen am Ende des Baumes wandert und die dabei gefundenen Beschriftungen an den Verzweigungen notiert.<br><br>  
   
      <b> 12. MASCHINELLES LERNEN</b><br><br>

 Maschinelles Lernen l√§sst sich als Teilgebiet der k√ºnstlichen Intelligenz betiteln. Hierbei wird Lernen als: ‚Äû[‚Ä¶] ein Prozess [dargestellt], der zu einer Performanzsteigerung eines Systems f√ºhrt.‚Äú
Das System ist hierbei der Computer, oder der Mensch und die Performanzsteigerung stellt die Verhaltens√§nderung im Hinblick auf die Optimierung einer Bewertungsfunktion dar.
Ein k√ºnstliches System lernt aus Beispielen und kann nach Beendigung der Lernphase verallgemeinern. Es lernt dabei nicht einfach Beispiele auswendig, sondern es erkennt Gesetzm√§√üigkeiten in den Lerndaten. So kann das System auch unbekannte Daten beurteilen.<br><br>

      <b>INDUKTIVES LERNEN</b><br>
= aus dem Speziellen, das Allgemeine lernen<br>
‚Üí die Idee ist die, dass man eine Funktion aus Beispielen lernen soll und mithilfe von gegebenen Fakten, Hypothesen aufstellt<br>
Ablauf: Funktion finden ‚áí Funktion passt f√ºr m√∂glichst viele Beispiele ‚áí Funktion wird verallgemeinert<br>

      BEISPIEL:<br>
Gegeben: Schwimmt (Forelle), Schwimmt (Karpfen)<br>
Folgerung: Schwimmt (Fisch)<br>
‚Üí Vom Spezifischen auf das Allgemeine<br><br>

      <b>LATENT SEMANTIC ANALYSIS</b><br>
= Verfahren der automatischen Sprachverarbeitung<br>
‚Üí dient also dazu, um √Ñhnlichkeiten zwischen unterschiedlichen Ausdr√ºcken zu errechnen<br>

Ziel: die generellen Begriffe eines Dokumentes zu finden<br>
Idee: W√∂rter, die h√§ufig im Dokument vorkommen, haben eine latent √§hnliche Bedeutungen<br><br>

      <b>BEISPIEL:</b><br>
‚Üí aus sehr viele Daten (z.B. im Internet) sollen diejenigen gefunden werden, in denen das Wort Auto vorkommt<br>
‚Üí auch diejenigen, in denen es um das Thema Auto geht, aber der Name nicht explizit im Dokument genannt wird<br>
‚Üí kann Dokumente unterscheiden, in denen es wirklich um Autos geht und in denen nur das Wort Auto vorkommt (wie zum Beispiel Gewinnspiele)<br><br>

      <b>FUNKTIONSWEISE:</b><br>
‚Üí Worterscheinung werden als Matrix gesammelt<br>
‚Üí in Spalten werden die Erscheinungsmengen der W√∂rter gesammelt<br>
‚Üí in den Reihen die Dokumente     <br><br>

      <b>13. FAZIT</b> <br><br>

Meine Erfahrungen mit dem Kurs Fundamentale Ideen der Informatik waren eher negativ, da meine Kohorte den Kurs aufgrund von Ausf√§llen nur sehr selten besuchen konnte. Au√üerdem haben wir auch kein Folien von Herrn Beer zur Verf√ºgung gestellt bekommen, weshalb ich mit den Materialien von Herrn Libbrecht gearbeitet habe. Aufgrund von einer sprachlichen Barriere fiel es mir sehr schwer etwas zu verstehen, weshalb ich mich oft auf eigene Recherchen bezogen habe. Dadurch konnte ich das E-Portfolio dann aber vervollst√§ndigen und nachvollziehen.     
      
      <h1 class="Schwerpunkte">Schwerpunkte</h1>
      <p class="Schwerpunkte">Unter diesem Reiter finden Sie meine beiden Schwerpunkte zu den Vorlesungen ‚ÄûProgrammieren in einer objektorientierten Umgebung‚Äú und ‚ÄûFundamentale Ideen der Informatik‚Äû. Viel Spa√ü beim Durchst√∂bern! üôÇ</p>
      
      <h2 class="Programmieren in einer objektorientierten Umgebung ‚Äì Schwerpunkt">Programmieren in einer objektorientierten Umgebung ‚Äì Schwerpunkt</h2> 
      <p class="Programmieren in einer objektorientierten Umgebung ‚Äì Schwerpunkt"> <b>HERO TROUBLE</b> <br><br>
          <b> EINF√úHRUNG</b> <br><br>
Ich habe zusammen mit meiner Gruppe, mit Sophia Pournaras, Stefan Maisch und Tim Reisenauer, das Spiel ‚ÄúHero Trouble‚Äù entwickelt. Unser Spiel basiert auf dem bereits vorhandenem Spiel ‚ÄúTank Trouble‚Äù (https://www.tanktrouble.com), in dem es darum geht den bzw die gegnerischen Panzer abzuschie√üen. Dabei befinden sich die einzelnen Panzer an verschiedenen Stellen in einem Labyrinth. Es ist m√∂glich dieses Spiel alleine gegen einen Computer, zu zweit oder zu dritt zu spielen. </p>
Bei unserem Spiel, ‚ÄúHero Trouble‚Äù, handelt es sich um ein sehr √§hnliches Konzept. Es ist als Zwei-Spieler-Spiel konzipiert, und es geht darum, dass Superman (Spieler 1) und Batman (Spieler 2) sich gegenseitig abschie√üen, bzw sich nicht abschie√üen lassen. Diese befinden sich auch in einem Labyrinth, welches Hindernisse beziehungsweise Begrenzungen darstellt.<br><br>    
      <b>KONZEPTION</b><br><br>
Nachdem wir uns auf eine Spielidee geeinigt haben, ging es f√ºr uns an die Arbeit. Zuerst begaben wir uns auf die Suche nach Spielfiguren. Schnell haben wir die Illustrationen von Batman und Superman (https://img.etsystatic.com/il/c6033d/1347625235/il_fullxfull.1347625235_o26v.jpg) gefunden und uns f√ºr diese entschieden. Daraufhin haben wir diese mit Photoshop zurecht geschnitten und uns dem Aufbau des Startfensters und des Labyrinths gewidmet. Diese Aufgaben haben wir aufgeteilt, zwei von uns entwickelten das Labyrinth und die anderen beiden schrieben den ersten Teil des Codes f√ºr das Startfenster. Auf den genauen Code werde ich unter dem Punkt ‚ÄúUmsetzung‚Äù zur√ºckkommen.
Um die Koordinaten leichter festlegen zu k√∂nnen, haben wir das Labyrinth direkt in einem Koordinatensystem gezeichnet. Die obere, linke Ecke lag dabei nicht im Nullpunkt, sondern bei (100/100). Nachdem wir die √§u√üeren Linien festgelegt haben, haben wir nach und nach die im Labyrinth liegenden Linien definiert.<br>
Dies bringt mich auch schon in die Phase der Umsetzung. <br> <br>

      <b>UMSETZUNG </b><br><br>
In dem Programmcode, den ich Ihnen in einer Dropbox zur Verf√ºgung gestellt habe, steht schon sehr detailliert, wozu die einzelnen Elemente dienen, weshalb ich hier nur auf besondere Teile des Spielcodes eingehen werde.     
Nach dem Programmkopf, in welchem wir allgemeine Daten, wie den Spielnamen festgelegt haben, haben wir dargestellt, dass wir eine externe Datei einbinden m√∂chten. (Auf diese Datei werde ich sp√§ter noch einmal zur√ºckkommen).
Als n√§chstes haben wir die Shoes App mit ‚ÄúShoes.app do‚Äù gestartet und den Titel des Spiels und die nicht ver√§nderbare Gr√∂√üe des Fensters bestimmt.
Zun√§chst haben wir grundlegende Dinge f√ºr das Start- und Steuerungsfenster eingestellt. WIrd nun der Button ‚ÄúPlay‚Äù bet√§tigt, beginnt der Hauptteil des Programmcodes.
Als erstes werden die Linien des Labyrinths, von denen ich vorher schon einmal gesprochen habe, aufgerufen.   
Nun werden ‚ÄúOvale‚Äù, die die Schusspatronen der Spieler darstellen, einmal festgelegt, damit sie beim ersten ‚Äúremove‚Äù Befehl, entfernt werden. Dies dient dazu, dass wenn die Spieler sp√§ter schie√üen m√∂chten, die davor abgeschossene Schusspatrone entfernt (also removed) wird, sobald die n√§chste abgefeuert wurde.
Damit die Sch√ºsse sp√§ter auch funktionieren, werden Sie nun in zwei Funktionen, eine f√ºr jeden Spieler, definiert. Innerhalb der Funktionen sind einige Kontrollstrukturen in einander verschachtelt, um jede m√∂gliche Bedingung zu erf√ºllen. Ebenfalls wird hier definiert, dass Spieler 1 mit der Taste ‚ÄúQ‚Äù und Spieler 2 mit der Taste ‚ÄúM‚Äù schie√üt.      
Danach, haben wir die Startpositionen und die Steuerung der beiden Spielfiguren festgelegt. Auch hier findet man eine Verkettung von mehreren Fallentscheidungen wieder.
Mit einem keypress-Event, werden dann die zuvor festgelegten Kontrollstrukturen, welche, bzw ob eine Taste aufgerufen wird, √ºberpr√ºft.      
Als letztes wird die zuvor genannte, ausgelagerte Funktion noch aufgerufen. In dieser Funktion, haben wir festgelegt, dass wenn Spieler 1 oder Spieler 2, die Linien des Labyrinths ber√ºhren, sie diese nicht durchdringen k√∂nnen und begrenzt werden. Au√üerdem werden sie immer wenn sie eine Linie ber√ºhrt haben, ein St√ºck weiter in die Mitte des davor genutzten Weges gesetzt.
Die Funktion haben wir deshalb ausgelagert, da sie sehr lang und daher un√ºbersichtlich und unstrukturiert wirkt.  <br><br>    
 
      <b>FAZIT</b><br><br>
Zusammenfassend kann ich sagen, dass mir das Programmieren des Spiels mehr Freude als erwartet bereitet hat, da ich vor dieser Vorlesung noch nie in Kontakt mit irgendeiner Art von Programmieren gekommen bin.
Es war stets interessant und f√ºr mich pers√∂nlich auch sehr verlockend, wenn etwas mal nicht funktioniert hat und wir nach der L√∂sung suchen mussten, damit alles perfekt l√§uft.
Es hat mir sehr viel Freude bereitet dieses Spiel zu programmieren, und bin sehr stolz sagen zu k√∂nnen, dass dies unser Werk ist!
      
      <h2 class="Fundamentale Ideen der Informatik ‚Äì Schwerpunkt">Fundamentale Ideen der Informatik ‚Äì Schwerpunkt</h2>
      <p class="Fundamentale Ideen der Informatik ‚Äì Schwerpunkt"> VERSCHL√úSSELUNG ‚Äì <b>ADVANCED ENCRYPTION STANDARD </b><br><br>
          
<b> EINF√úHRUNG VERSCHL√úSSELUNG: </b><br> <br>

Unter Verschl√ºsselung versteht man Verfahren und Algorithmen, die Daten mittels digitaler bzw. elektronischer Codes oder Schl√ºssel inhaltlich in eine nicht lesbare Form umwandeln. Diesen Vorgang bezeichnet man als Verschl√ºsseln. Gleichzeitig wird daf√ºr gesorgt, dass nur mit dem Wissen eines Schl√ºssels die geheimen Daten wieder entschl√ºsselt werden k√∂nnen.
Anstatt von Verschl√ºsselung spricht man auch von Chiffrierung, was das gleiche meint.<br><br>
          <b>EINF√úHRUNG ADVANCED ENCRYPTION STANDARD:</b>br>

Der Advanced Encryption Standard (AES) ist eine Blockchiffre, die als Nachfolger f√ºr DES im Oktober 2000 vom National Institute of Standards and Technology (NIST) als Standard bekanntgegeben wurde. Nach seinen Entwicklern Joan Daemen und Vincent Rijmen wird AES auch Rijndael-Algorithmus genannt.
Es handelt sich um ein symmetrisches Verschl√ºsselungsverfahren. Der Rijndael-Algorithmus besitzt variable, voneinander unabh√§ngige Block- und Schl√ºssell√§ngen von 128, 160, 192, 224 oder 256 Bit. Au√üerdem bietet dieser ein sehr hohes Ma√ü an Sicherheit; ‚Üí erst mehr als zehn Jahre nach seiner Standardisierung wurde der erste theoretisch interessante, praktisch aber nicht relevante Angriff gefunden.<br><br>
          
<b>ENTSTEHUNG ADVANCED ENCRYPTION STANDARD:</b><br>
Im Januar 1997 schrieb das amerikanische Handelsministerium eine Suche nach einem Nachfolger des DES-Verfahrens aus, da dieses als Verschl√ºsselungsverfahren nicht mehr so gut funktionierte, da es auf eine Datengr√∂√üe von 56 Bit beschr√§nkt war. Es wurden folgende Rahmenbedingungen gegeben, die das zuk√ºnftige AES Verfahren erf√ºllen musste:<br>
muss ein symmetrischer Algorithmus sein<br>
muss 128 Bit lange Bl√∂cke verwenden<br>
muss Schl√ºssel von 128, 192 und 256 Bit L√§nge einsetzen k√∂nnen<br>
soll gleicherma√üen leicht in Hard- und Software zu implementierbar sein<br>
soll eine √ºberdurchschnittliche Leistung haben<br>
soll allen bekannten Methoden der Kryptoanalyse widerstehen k√∂nnen, insbesondere Power- und Timing-Attacken<br>
geringe Ressourcen Erforderlichkeit<br>
frei von patentrechtlichen Anspr√ºchen sein und muss von jedermann unentgeltlich genutzt werden k√∂nnen<br>
Neben Joan Daemen und Vincent Rijmen gab es noch Teilnehmer aus vielen weiteren L√§ndern, die ihre Ideen pr√§sentiert haben. Auch Deutschland wurde durch die Deutsche Telekom mit der ‚ÄûMagenta‚Äú als Idee vertreten. Aufgrund von massiver Sicherheits- und Leistungsprobleme wurde diese dann aber nicht ausgew√§hlt.       
In Bezug auf die drei Hauptkriterien, Kosten, Implementierung und Sicherheit, entschied sich die NIST (National Institute of Standards and Technology) f√ºr das Rijndael Verfahren.<br><br>

          <b>ABLAUF:</b><br>
Rijndael sind Blockchiffren auf Basis eines Substitutions-Permutations-Netzwerks (SPN). Das Verfahren wechselt bei jedem Schritt zwischen Substitution und Permutation, weshalb man AES auch als SP-Chiffre bezeichnet. Dabei erfolgt die Transformation des Klartextes in mehreren Runden gleichen Aufbaus. Der Klartext wird dabei nicht als Ganzes, sondern in Bl√∂cken verarbeitet. Hierbei findet eine Konfusion statt, es wird also unter anderem die Beziehung zwischen Klar- und Geheimtext verwischt.
Die Blockl√§nge unterscheidet sich zwischen Rijndael und AES etwas, bei Rijndael k√∂nnen die Block- und Schl√ºssell√§nge unabh√§ngig voneinander die Werte 128, 160, 192, 224 oder 256 Bits haben. Bei AES wurde die Blockl√§nge auf 128 Bit und die Schl√ºsselgr√∂√üe auf 128 (10 Runden), 192 (12 Runden) und 256 Bit (14 Runden), nach den Anforderungen von der NIST, festgelegt.
Die AES-Entschl√ºsselung sieht notwendigerweise vor, dass dieselben Schritte wie bei der Verschl√ºsselung durchlaufen werden m√ºssen, nur eben in umgekehrter Reihenfolge.
Jeder Block wird zun√§chst in eine zweidimensionale Tabelle mit vier Zeilen geschrieben, dessen Zellen ein Byte gro√ü sind. Die Anzahl der Spalten variiert je nach Blockgr√∂√üe von 4 (128 Bit) bis 8 (256 Bit). Jeder Block wird nun nacheinander bestimmten Transformationen unterzogen. Aber anstatt jeden Block einmal mit dem Schl√ºssel zu Chiffrieren, wendet AES verschiedene Teile des Schl√ºssels nacheinander auf den Klartext-Block an. Die Anzahl dieser Runden (r) variiert und ist von Schl√ºssell√§nge (k) und Blockgr√∂√üe (b) abh√§ngig:<br><br>
 
Der weitere Ablauf ist dann in folgende Schritte eingeteilt:<br>

Schl√ºsselexpansion<br>
Vorrunde<br>
KeyAddition ()<br>
Verschl√ºsselungsrunden (wiederhole solange runde<r)<br>
Substitution()<br>
ShiftRow()<br>
MixColumn()<br>
KeyAddition()<br>
Schlussrunde<br>
Substitution()<br>
ShiftRow()<br>
KeyAddition()<br>
‚Üí Die Schlussrunde z√§hlt auch als Runde, also R = Anzahl Verschl√ºsselungsrunden + 1 Schlussrunde<br><br>

<b>SCHL√úSSELEXPANSION</b><br>
zun√§chst werden aus dem Schl√ºssel R + 1 Teilschl√ºssel, auch Rundenschl√ºssel genannt, erzeugt
Die Rundenschl√ºssel m√ºssen die gleiche L√§nge wie die Bl√∂cke haben
Mathematisch dargestellt hei√üt dies dann ‚Äûb*(R+1)‚Äú wobei b die Blockl√§nge angibt
Der Schl√ºssel wird dann in eine zweidimensionale Tabelle mit vier Zeilen und Zellen, die jeweils 1 Byte gro√ü sind, abgebildet
Die ersten Spalten werden dann mit dem Benutzerschl√ºssel gef√ºllt
Alle weiteren Spalten werden rekursiv berechnet:
Um die Werte f√ºr die Zellen in der n√§chsten Spalte zu erhalten, werden die Spalten, welche je nach Blockgr√∂√üe ein Vielfaches der vierten, sechsten oder achten Spalte sind, nach links rotiert [a0,a1,a2,a3] wird zu [a1,a2,a3,a0] und mit Hilfe der S-Box verschl√ºsselt
Danach wird der ‚Äûvorderste‚Äú Wert der Spalte mit der rcon-Tabelle XOR verkn√ºpft und abschlie√üend die gesamte Spalte mit der um eine Schl√ºssell√§nge zur√ºckliegenden Spalte XOR verkn√ºpft
Alle anderen Spalten werden aus einer XOR-Verkn√ºpfung mit der Spalte eine Schl√ºssell√§nge vorher gebildet
Eine Ausnahme bildet AES-256
Hierbei wird jede 4. Spalte durch die S-Box ersetzt und dann mit der Spalte eine Schl√ºssell√§nge davor XOR-verkn√ºpft <br> <br>          
          
          <b>ADDROUNDKEY</b><br><br>

Die KeyAddition wird in der Vorrunde und am Ende jeder anderen Verschl√ºsselungsrunde ausgef√ºhrt
Hier wird eine bitweise XOR-Verkn√ºpfung zwischen dem Block und dem aktuellen Rundenschl√ºssel vorgenommen
Dies ist die einzige Funktion in AES, die den Algorithmus vom Benutzerschl√ºssel abh√§ngig macht<br> <br>
 

          <b>SUBBYTES</b> <br><br>

Im ersten Schritt jeder Runde wird f√ºr jedes Byte im Block ein √Ñquivalent in der S-Box gesucht
so werden die Daten monoalphabetisch verschl√ºsselt<br><br>
 

          <b>SHIFTROWS</b><br><br>

In diesem Schritt werden die Zeilen um eine bestimmte Anzahl von Spalten nach links verschoben
√úberlaufende Zellen werden von rechts fortgesetzt
Die Anzahl der Verschiebungen h√§ngt von den Block und Zeilenl√§ngen ab
Die Zeile wird entweder um 1 bis 4 Spalten verschoben <br><br>        
 
          <b>MIXCOLUMN</b><br><br>

Nun werden die Spalten vermischt
Es wird zun√§chst jede Zelle einer Spalte mit einer Konstanten multipliziert und anschlie√üend die Ergebnisse XOR verkn√ºpft
Hinter dieser Vorgehensweise steckt ein komplizierter mathematischer Zusammenhang, den ich hier nicht n√§her erl√§utere<br><br>
 

          <b>ENTSCHL√úSSELUNG</b><br><br>

Hier wird r√ºckw√§rts vorgegangen
Die Daten werden zun√§chst wieder in zweidimensionale Tabellen gelesen
Danach werden die Rundenschl√ºssel generiert
Allerdings wird nun mit der Schlussrunde angefangen und alle Funktionen in jeder Runde in der umgekehrten Reihenfolge aufgerufen
Durch die vielen XOR-Verkn√ºpfungen unterscheiden sich die meisten Funktionen zum Entschl√ºsseln nicht von denen zum Verschl√ºsseln
Es muss eine andere S-Box genutzt werden (die sich aus der original S-Box berechnen l√§sst) und die Zeilenverschiebungen erfolgen in die andere Richtung<br><br>
 

          <b>ANWENDUNGSBEREICHE</b><br><br>

AES findet einen sehr gro√üen Anwendungsbereich, wie zum Beispiel f√ºr folgende Programme:<br>
Verschl√ºsselungsstandard IEEE 802.11i f√ºr Wireless LAN<br>
SRTP<br>
Skype<br>
Mac OS X als Standardverschl√ºsselungsmethode f√ºr Disk-Images<br>
FileVault<br>
Komprimierte Dateiarchive wie 7-ZIP oder RAR<br><br>
 

          <b>KRITIK</b><br><br>

Je nach verwendetem Schl√ºssel besteht nur eine Sicherheitsmarge von drei (bei 128 Bits Schl√ºssell√§nge) bis f√ºnf Runden (bei 256 Bits Schl√ºssell√§nge)
Einfache algebraische Beschreibung der S-Boxen, die ihrerseits die einzige nichtlineare Komponente der Chiffre sind
Deshalb l√§sst sich der gesamte Algorithmus als Gleichungssystem beschreiben
Durch den einfachen Key Schedule w√ºrden mit einem beliebigen Rundenschl√ºssel auch 128 Bit des Verfahrensschl√ºssels kompromittiert          
          
          
          
 </p>   
      </div>
    
    
    

<!-- Cmap Bereich -->

  <div id="cmap" class="svg">
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1173px" height="596px" style="background-color:#ffffff;">

        <!-- Connection Lines -->
            <g>
                <path d="M469 68L428 101" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M410 115L377 139" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M528 68L580 107" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M598 121L624 141" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M330 175L305 194" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M286 208L258 228" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M370 175L391 197" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M404 211L420 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M634 177L617 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M607 214L597 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M673 177L706 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M725 214L747 231" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
        
        <!-- Linking Phrases -->
            <g>
                <g>
                    <text x="387px" y="113px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="557px" y="119px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="264px" y="206px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="366px" y="209px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="587px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="684px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
        
        <!-- Concepts -->
            <g>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="460px" y="54px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="16pt" font-family="Verdana">
                        <tspan>Thema</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="291px" y="165px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="585px" y="167px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="185px" y="252px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="389px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="538px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>3</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="723px" y="255px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>4</tspan>
                    </text>
                </g>
            </g>
        </svg>
  </div>
   
  <script type="text/javascript" src="navigation.js"></script>
</body>
</html>

