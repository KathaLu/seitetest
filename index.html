<html lang:"de"="">
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css" type="text/css">
    <title>IT3 E-Portfolio</title>
    
  </head>
<!-- Body Bereich -->     
<body>
  <div id="inhalt" class="inhalt">
    <h1 class="Vorlesungen">Vorlesungen</h1>
    <p class="Vorlesungen">Unter diesem Reiter finden Sie meine beiden Zusammenfassungen zu den Vorlesungen â€Programmieren in einer objektorientierten Umgebungâ€œ und â€Fundamentale Ideen der Informatikâ€. Viel SpaÃŸ beim DurchstÃ¶bern!ğŸ™‚</p>
     
      <h2 class="Programmieren in einer objektorientierten Umgebung">Programmieren in einer objektorientierten Umgebung</h2>
      <p class="Programmieren in einer objektorientierten Umgebung"> <b>1. EINFÃœHRUNG IN RUBY</b> <br> <br>
Ruby wurde zwei Jahre lang von Yukihiro Matsumoto entwickelt, und im Jahr 1995 verÃ¶ffentlicht. Bis dahin war Ruby eine vollkommen unbekannte Sprache. 2004 wurde das Webframework Ruby on Rails verÃ¶ffentlicht, und Rubys Durchbruch erfolgte. Heute gehÃ¶rt Ruby zu den am meist verbreiteten Programmiersprachen der Welt.
Ruby ist eine sogenannte interpretierte Skriptsprache. Das bedeutet, ein Ruby-Programm wird vom Ruby-Interpreter geÃ¶ffnet, Zeile fÃ¼r Zeile gelesen und die Ruby-Anweisungen in Maschinensprache Ã¼bersetzt. Um also ein Ruby-Programm ausfÃ¼hren zu kÃ¶nnen, muss auf dem Rechner ein entsprechender Interpreter installiert sein.
Ruby ist auÃŸerdem eine objektorientierte Sprache, was heiÃŸt, dass jeder Wert ein Objekt ist, und jedes Objekt zu einer Klasse gehÃ¶rt.</p>
      <br> 
      <b> WARUM RUBY?</b> <br>
Ruby ist eine freie Programmiersprache, das heiÃŸt also, dass diese kostenlos, frei zu benutzen, zu kopieren, zu verÃ¤ndern und zu verbreiten ist. AuÃŸerdem bietet Ruby einen guten Einstieg in die Programmierung, da es relativ einfach zu lernen ist. Die Befehle kÃ¶nnen dazu auch besser verstanden werden, da sie an der englischen Sprache orientiert sein. Dazu unterstÃ¼tzt Ruby die neuesten, wichtigen Programmiermethodiken: Objektorientierung, XP, und auch mehrere Programmierparadigmen. Ein weiterer sehr wichtiger Aspekt ist, dass Ruby der menschlichen Denkweise sehr Ã¤hnelt. <br> <br>
<b> EXKURS </b> <br> <br>
 ASSEMBLER<br>
â†’ fÃ¼r den Menschen lesbare Sprache <br>
â†’ Umwandlung in Maschinensprache notwendig <br>
â†’ zu umstÃ¤ndlich und fehleranfÃ¤llig <br> <br>
      COMPILER<br>
â†’ Ã¼bersetzt das in Hochsprache formulierte Programm in Maschinensprache, das dann ausgefÃ¼hrt werden kann <br> <br>
      INTERPRETER <br>
â†’ analysiert das in Hochsprache formulierte Programm und aktiviert direkt die entsprechenden Maschinenbefehle <br> <br>
      <b>ALGORITHMEN UND PROGRAMME</b> <br>
Algorithmen sind genau definierte Handlungsvorschriften die zur LÃ¶sung eines Problems dienen. Ein dafÃ¼r alltÃ¤gliches Beispiel sind Kochrezepte, in welchem beschrieben wird, in welcher Reihenfolge Schritte zu erledigen sind.
Programme sind konkrete Formen von Algorithmen. Diese bestehen aus mehreren Anweisungen, die dann vom Computer interpretiert, und in der Reihenfolge durchgefÃ¼hrt werden. <br> <br>
      <b>ERSTE ANWEISUNGEN</b> <br>
Ãœblicherweise wird eine einfache Anweisung in eine Zeile geschrieben. Diese orientiere sich an der natÃ¼rlichen, also englischen Sprache.<br>
puts â€“ es erfolgt eine Ausgabe mit Zeilenumbruch <br>
print â€“ es erfolgt eine Ausgabe ohne Zeilenumbruch <br>
Raute (#) â€“ hierbei handelt es sich um einen Kommentar; die Raute und alles das in der Zeile danach steht wird vom Ruby-Interpreter ignoriert <br>
#=> â€“ eine Raute mit einem darauffolgenden Pfeil zeigt an, welcher Wert bei dem Code herauskommen wÃ¼rde, wenn man ihn ausfÃ¼hren wÃ¼rde <br> <br>
      <b>2. DATENTYPEN UND VARIABLEN </b> <br> <br>

      <b> DATENTYPEN </b> <br>
Daten, ihre AusfÃ¼hrung und Manipulation bilden die Basis von Computerprogrammen. In Ruby sind folgende, einfache und komplexe Datentypen vordefiniert: <br><br>

      <b>EINFACHE DATENTYPEN</b> <br>

Zahlen: â€¦werden in Ruby meist wie im realen Leben eingesetzt; zum Rechnen, als Index, etc. Unterschieden wird zwischen ganzzahligen Werten (Integer wie 1; -1; 1000) und FlieÃŸkommazahlen (Float wie 1.2; 3.06; -6.66) <br>

Zeichen: â€¦ist ein einzelner Buchstabe, Ziffer, Leerzeichen oder sonstiges typografisches Symbol. <br>

Zeichenketten (String): â€¦eine Kette von Zeichen (Buchstaben, Zahlen etc.) umschlossen von einfachen oder doppelten AnfÃ¼hrungszeichen <br>

String-Interpolation â€“ Besonderheit:Strings in doppelten AnfÃ¼hrungszeichen kÃ¶nnen beliebige Ruby-AusdrÃ¼cke beinhalten. 

Wenn der String erzeugt wird, wird der Ausdruck ausgewertet, in einen String konvertiert und anstelle des Ausdrucks selbst in die Zeichenkette eingefÃ¼gt.

AusdrÃ¼cke innerhalb eines Strings beginnen mit dem Raute-Zeichen (#) und werden von geschweiften Klammern ({ }) umschlossen:

puts â€1 + 2 = #{1+2}â€œ #=> 1 + 2 = 3

Boolean / Boolsche Werte: â€¦logische Aussage, kann wahr (true), falsch (false) oder leer (nil) sein

In manchen FÃ¤llen ist eine Umwandlung der Datentypen notwendig. Ein Beispiel finden Sie in der ersten Ãœbung zu diesem Kapitel. HierfÃ¼r gibt es folgende Befehle:<br><br>

      <b>UMWANDLUNG DER DATENTYPEN</b> <br>
      to_s â€“ Umwandlung zu einem String
      to_i â€“ Umwandlung zu einem Integer
      .to_f â€“ Umwandlung zu einem Float <br> <br>

      <b> VARIABLEN</b> <br>

Variablen haben in Programmiersprachen eine wichtige Rolle. Sie erleichtern einem das Nutzen und Schreiben von Programmen. Wird einer Variable einmal ein Wert zugeordnet, kann dieser beliebig oft genutzt und aufgerufen werden.
Variablen kann man sich wie ein GefÃ¤ÃŸ vorstellen, in dem ein Wert hinterlegt wird. Variablen kÃ¶nnen anhand von beliebigen Datentypen hinterlegt werden. Egal ob String, Boolean, oder einfach nur eine Zahl.
Es wird weiter unterschieden zwischen lokalen und globalen Variablen.
Lokale Variablen werden entweder durch einen Unterstrich oder einen Kleinbuchstaben zu Beginn der Variable gekennzeichnet. Sie gelten fÃ¼r die Methode, fÃ¼r die sie definiert werden. Wenn aber eine Methode bereits eine Variable verwendet, greift sie auf diese zurÃ¼ck, und erstellt keine neue.
Globale Variablen werden mit einem $ gekennzeichnet. Diese sind immer und Ã¼berall im Ruby Programm sichtbar. Es gibt auch globale Variablen, die keinen zugewiesenen Wert haben, besitzen dann automatisch den Wert nil. <br> <br>
      <b> LITERALE UND AUSDRÃœCKE</b> <br><br>

      <b>LITERALE</b> <br>

Um bestimmte AusdrÃ¼cke zu erzeugen, gibt es eine Art Kurzsyntax, die Literale. Einfach ausgedrÃ¼ckt sind Literale Abfolgen von Ziffern und Zahlen.
â€˜ein String Literalâ€™ <br> <br>
      <b>AUSDRÃœCKE</b><br>
Ein Ausdruck ist ein StÃ¼ck Code, der vom Ruby-Interpreter ausgewertet wird, um einen Wert zu erzeugen. PrimÃ¤rausdrÃ¼cke sind die einfachsten mÃ¶glichen AusdrÃ¼cke, die nicht aus einfacheren AusdrÃ¼cken zusammengesetzt sind. Dazu gehÃ¶ren Literale, Referenzen auf Variablen und Aufrufe von Methoden.
Es kÃ¶nnen ebenfalls grÃ¶ÃŸere AusdrÃ¼cke erzeugt werden. Dies erfolgt indem man PrimÃ¤rausdrÃ¼cke durch Operatoren kombiniert werden. <br> <br>
      <b>3. ANWEISUNGEN UND FUNKTIONEN</b><br><br>

      <b>OPERATOREN</b> <br>

Ein Ausdruck wird Ã¼blicherweise aus Werten und Operatoren gebildet. Hierbei gibt es unter anderem die arithmetischen Operatoren, Zuweisungsoperatoren oder logischen Operatoren.<br> <br>
      <b> FUNKTIONEN</b><br>
Funktionen sind CodeblÃ¶cke, die einmal definiert werden und auf die dann beliebig oft zurÃ¼ckgegriffen werden kann. So lÃ¤sst sich ein Programm besser strukturieren und der Code kompakt halten.
Die zwei SchlÃ¼sselwÃ¶rter fÃ¼r Definitionen sind def und end. Man beginnt mit â€œdefâ€, woraufhin der Funktionsname und optionale ein oder mehrere Parameter in Klammern folgen.
Im Funktionsrumpf befindet sich der Ruby-Code, der bei Aufruf der Funktion ausgefÃ¼hrt wird. Die Parameter werden hier wie normale Variablen verwendet. Das Ende wird dann mit â€œendâ€ gekennzeichnet.
Allgemein formuliert sieht dies dann so aus:
def name (parameter)
Funktionsrumpf
â€¦
â€¦
end <br> <br>
      <b>4. KONTROLLSTRUKTUREN</b> <br><br>

Kontrollstrukturen dienen dazu den geradlinigen Programmfluss zu unterbrechen und an anderen Stellen zu verzweigen. Dies geschieht in Form von Fallentscheidungen oder Schleifen.<br><br>

      <b>FALLENTSCHEIDUNGEN</b><br>

Das wichtige bei Fallentscheidungen ist, dass sie immer mindestens eine, oder mehrere Bedingungen enthalten. Je nach dem ob die Bedingung erfÃ¼llt ist, oder nicht, wird ein bestimmtes StÃ¼ck Code ausgefÃ¼hrt.<br>

â†’ Es handelt sich hierbei also um Boolâ€™sche AusdrÃ¼cke. Anweisungen werden dann ausgefÃ¼hrt, je nach dem, ob eine Bedingung true oder false ist.<br><br>

      <b>SCHLEIFEN</b><br>
Schleifen bewirken, dass ein Code-StÃ¼ck wiederholt und somit mehrmals ausgefÃ¼hrt wird.<br><br>
      
      <b>  ITERATOREN</b> <br>

Eine Alternative Wiederholungen zu erzeugen, wird durch Iteratoren geboten. Ein Iterator schreitet durch eine Liste von Elementen und arbeitet diese Element fÃ¼r Element ab. Unter anderem gibt es die numerischen Iteratoren times, upto und downto.
Die Methode times ruft ihren zugehÃ¶rigen Codeblock genau n-mal auf. (Sie geht also durch eine Liste aufeinanderfolgender Zahlen mit n Elementen beginnend bei 0. Dies kann so aussehen:
3.times do
print â€œhaha!â€
end
# => haha!haha!haha!
Wird die Methode durch einen formalen Parameter erweitert, so zeigt dieser den Wert der aktuellen Iteration an und Ã¼bergibt ihn dem Codeblock:
3.times do |x|
print x
end
# => 012
Die Methode upto ruft ihren zugehÃ¶rigen Block einmal fÃ¼r jeden Wert auf, der zwischen dem Integer, fÃ¼r den sie aufgerufen wird und dem Integer, der als Argument Ã¼bergeben wird, liegt:
3.upto(5) do |x|
print x
end
# => 345
Die Methode downto funktioniert im Prinzip wie upto, nur anders herum, das heiÃŸt sie iteriert von der grÃ¶ÃŸeren zur kleineren Zahl:
5.downto(3) do |x|
print x
end
# => 543
Durch die Methode step kann eine verÃ¤nderte Schrittweite angegeben werden. Sie wird wie upto fÃ¼r einen Startwert aufgerufen, als Argumente werden ebenfalls der Endwert und zusÃ¤tzlich die Schrittweiter Ã¼bergeben:
3.step(5, 0.5) do |x|
print x
print â€œ;â€
end
# => 3.0;3.5;4.0;4.5;5.0 <br> <br>
      
     <b> CODEBLÃ–CKE </b><br>

Die Verwendung von BlÃ¶cken ist eine der Grundlagen der Verwendung von Iteratoren. Der Code zwischen do und end wird als Codeblock oder anonyme Funktion bezeichnet.

Ein Block kann nicht fÃ¼r sich allein stehen, sondern muss auf den Aufruf einer Methode folgen, der ihn ausfÃ¼hrt, wie es z.B. bei Iterationen der Fall ist.

BlÃ¶cke werden durch geschweifte Klammern oder die SchlÃ¼sselwÃ¶rter do und end umschlossen.{} bzw. do mÃ¼ssen sich dabei in der gleichen Zeile befinden wie der Methodenaufruf.

Der RÃ¼ckgabewert eines Blocks ist, wie auch bei Funktionen, der Wert des letzten Ausdrucks, der in dem Block ausgewertet wurde.

FÃ¼r die NamensrÃ¤ume von Variablen gilt:<br>

â†’ lokale Variablen, die innerhalb des Codeblocks erzeugt werden, sind auÃŸerhalb nicht verfÃ¼gbar<br>

â†’ existiert eine lokale Variable bereits auÃŸerhalb der Funktion, kann sie innerhalb verwendet werden, d.h. es wird keine neue Variable erzeugt<br> <br>

         <b>5. ARRAYS UND HASHES</b> <br><br>

         <b> ARRAYS</b><br>

Ein Array ist eine Liste mit mehreren Elementen. Die LÃ¤nge eines Arrays ist dynamisch, das heiÃŸt also, dass diese bei Bedarf mitwÃ¤chst.
Ein Array wird erzeugt, indem es mit einem Namen versehen wird, dem entweder [] oder Array.new zugewiesen wird:
liste = [ ]
liste = Array.new <br>
â†’ in diesen beiden FÃ¤llen ist das Array zunÃ¤chst leer<br>
â†’ soll es mit einer bestimmten LÃ¤nge erzeugt werden, wird beim Aufruf â€œArray.newâ€ in <br>
Klammern eine Zahl Ã¼bergeben:<br>
liste = Array.new(3)
Einem Array kÃ¶nnen auch direkt bei der Erstellung konkrete Werte Ã¼bergeben werden:
liste = [1,4,5,6,8]
liste = Array.new(3,â€Halloâ€)
# => [â€œHalloâ€, â€œHalloâ€, â€œHalloâ€] <br><br>

         <b>ZUGRIFF</b><br>

Der Zugriff auf einen bestimmten Wert im Array funktioniert Ã¼ber den Namen des Arrays und der Angabe der gewÃ¼nschten Stelle (dem Index) in eckigen Klammern:
liste = [2]
# => [5]
Es kann auch auf einen Teil, d.h. auf mehrere Werte im Array zugegriffen werden. Hierbei wird die erste und letzte Stelle im Array angegeben, auf deren Werte zugegriffen werden soll:
liste = [2..4]
# => [5,6,8] (also Zugriff auf die Werte an den Stellen 2 bis 4 im Array)
AuÃŸerdem kann ein Wert innerhalb des Arrays ersetzt werden:
liste[2] = 100
# => [1,4,100,6,8]
Bei negativen Indexzahlen erfolgt der Zugriff von hinten:
liste[-1] = [1,4,5,6,8]
# => [8] <br> <br>

         <b>METHODEN</b><br>

â†’ die LÃ¤nge von Arrays ist dynamisch und kann dementsprechend verÃ¤ndert werden:<br>
myArray.insert(stelle, wert)<br>
â†’ fÃ¼gt an der angegebenen Stelle ein neues Element ein und alle folgenden Elemente werden um eine Stelle nach hinten verschoben<br>
Beispielsweise so:
liste.insert(3, 10)
# => [1, 4, 100, 10, 6, 8]
myArray.delete(wert)
â†’ ebenso kÃ¶nnen bestimmte Werte im Array gelÃ¶scht werden, was dann so aussieht:
liste.delete(4)
# => [1, 100, 10, 6, 8]<br>
â†’ unter der Seite http://ruby-doc.org/core-2.5.0/Array.html findet man noch ganze viele andere Methoden, die man fÃ¼r Arrays anwenden kann!  <br> <br>   
       
         <b>  SORTIEREN</b><br>

Eine hÃ¤ufig auftretende Aufgabe in der Programmierung ist das Sortieren von Elementen innerhalb des Arrays. HierfÃ¼r wird unter anderem das Bubble-Sort Prinzip verwendet. Das Prinzip dabei ist, immer zwei nebeneinander liegende Elemente zu vergleichen und ggf. zu vertauschen.
Nebenstehend soll eine Reihe von Zahlen der GrÃ¶ÃŸe nach geordnet werden (GrÃ¶ÃŸtes nach rechts, Kleinstes nach links).
Jeweils zwei nebeneinander liegende Zahlen werden verglichen und die grÃ¶ÃŸere der beiden nach rechts verschoben.
Somit gelangt in einem Durchlauf die grÃ¶ÃŸte Zahl ganz nach rechts. Im nÃ¤chsten die zweitgrÃ¶ÃŸte Zahl an die zweite Stelle von rechts, usw.
Um die Reihe also vollstÃ¤ndig zu sortieren, werden n-1 DurchgÃ¤nge benÃ¶tigt.
Um nun konkret Werte in einem Array zu sortieren, wird Ã¼ber die Indexzahl auf die einzelnen Werte zugegriffen und diese miteinander verglichen. Um alle Werte zu erfassen, erfolgt dies in einer Schleife. Das heiÃŸt bei ersten Schleifendurchlauf wird der Wert an der Stelle 0 mit dem Wert an Stelle 1 vergleichen. Im nÃ¤chsten Durchlauf wird dann der Wert an Stelle 1 mit dem an Stelle 2 verglichen usw. Je nachdem, was ein Vergleich ergibt, werden die Werte an den Stellen vertauscht.<br> <br>
      
         <b>HASHES</b><br>

Ein Hash ist, wie ein Array, eine Menge von Werten. Anders als im Array sind diese allerdings nicht geordnet, sondern werden Ã¼ber einen SchlÃ¼ssel identifiziert. Das heiÃŸt fÃ¼r jeden SchlÃ¼ssel ist ein bestimmer Wert hinterlegt:
grauwerte = {â€œweissâ€=>255, â€œhellgrauâ€=> 100, â€œschwarzâ€=> 0}
Der Zugriff auf diese Werte erfolgt ebenfalls Ã¼ber den SchlÃ¼ssel:
grauwerte[â€œhellgrauâ€]
# => 100 <br> <br>

         <b>6. TEST-DRIVEN-DEVELOPMENT</b><br><br>

Test-Driven-Development bezeichnet eine Methode des Programmentwurfs bei der ein Programm schrittweise, begleitet von kontinuierlichem Testen entwickelt wird.   
         â†’ d. h. ein Teil des Programms wird entworfen, dann getestet und verbessert bis es keine Fehler mehr gibt <br>
â†’ dann wird das Programm erweitert, getestet, erweitert, getestet, und so weiter<br>
â†’ so sollen Fehler mÃ¶glichst frÃ¼h erkannt und gelÃ¶st werden<br>
Folgendes ist ein Beispiel dafÃ¼r:
Es soll eine neue Funktion erstellt werden, die testet, ob es sich bei einer Jahreszahl um ein Schaltjahr handelt.
Es gilt:<br>
â€“ ist die Zahl durch 4 teilbar, ist das Jahr ein Schaltjahr<br>
â€“ ist die Zahl durch 4 und durch 100 teilbar, ist das Jahr kein Schaltjahr<br>
â€“ ist die Zahl durch 4, 100 und 400 teilbar, ist das Jahr ein Schaltjahr<br>
Um die Funktion schrittweise zu entwickeln, wird nun zuerst ein Test erstellt:<br>
def assert( expression )
raise â€œFehler!â€ unless expression
end<br>
Der Test gibt eine Fehlermeldung aus, wenn der Ausdruck, fÃ¼r den er durchgefÃ¼hrt wird, nicht wahr ist.<br>
â†’ Nun geht es darum, das Programm schrittweise zu entwickeln und zwischendurch immer wieder zu testen.<br> <br>
      
      <b>7. OBJEKTORIENTIERUNG</b><br> <br>

Ruby ist eine objektorientierte Programmiersprache. Dies bedeutet, dass in einem Ruby-Programm Ideen umgesetzt und damit gearbeitet werden kann, wie man es auch im realen Leben tun wÃ¼rde.
So werden in einem Programm Klassen und Objekte erstellt, fÃ¼r die beliebige Eigenschaften und Beziehungen untereinander definiert werden kÃ¶nnen. Klassen sind sozusagen Vorlagen aus denen dann konkrete Objekte erzeugt werden. Innerhalb der Klasse kÃ¶nnen eine Reihe von Eigenschaften und Methoden definiert werden, die auf ein Objekt angewendet werden kÃ¶nnen.
Zur Veranschaulichung, hier ein Beispiel:<br>
â†’ es wird als erstes die Klasse â€œCatâ€ erstellt<br>
class Cat
attr_accessor :name, :age, :color
end
Der Name einer Klasse beginnt immer mit einem GroÃŸbuchstaben.
atrr_accessor definiert Instanzvariablen, das heiÃŸt Variablen, durch die Objekte der Klasse identifiziert werden kÃ¶nnen.
â†’ hier kann eine Instanz der Klasse Cat durch Name, Alter und Farbe identifiziert werden
â†’ aus dieser Klasse kÃ¶nnen nun Objekte erzeugt werden:
cat_instance = Cat.new
FÃ¼r das erzeugt Objekt kÃ¶nnen im nÃ¤chsten Schritt Attribute definiert werden:
cat_instance.name =â€Maxâ€
cat_instance.age = 3
cat_instance.color = â€œblackâ€
â†’ jetzt erzeuge ich eine neue Klasse Snake:
class = Snake
attr_accessor :name, :age, :color
end
! ein wichtiges Merkmal objektorientierter Sprachen ist die Vererbung â†’ somit ist es mÃ¶glich, fÃ¼r die Klassen â€œCatâ€ und â€œSnakeâ€ eine Superklasse â€œPetâ€ zu erzeugen â†’ â€œCatâ€ und â€œSnakeâ€ bilden also die Subklassen von â€œPetâ€ und erben damit alle Eigenschaften, die fÃ¼r die Klasse â€œPetâ€ zur VerfÃ¼gung stehen
â†’ also wird die Klasse â€œPetâ€ zunÃ¤chst definiert
class Pet
attr_accessor :name, :age, :color
end
â†’ jetzt werden die Subklassen definiert, dabei gibt â€œ<Petâ€ die Vererbung der Klasse Pet an
â†’ somit mÃ¼ssen Attribute, die fÃ¼r â€œPetâ€ gelten, fÃ¼r â€œCatâ€ und â€œSnakeâ€ nicht noch einmal definiert werden
class Cat < Pet
end
class Snake < Pet
end
â†’ es kÃ¶nnen allerdings aber auch spezifische Eigenschaften fÃ¼r einzelne Klassen hinzugefÃ¼gt werden
class Snake < Pet
attr_accessor :length
end
â†’ auÃŸerdem kÃ¶nnen bestimmte Methoden definiert werden, d. h. Anweisungen, die fÃ¼r Objekte der Klasse verwendet werden kÃ¶nnen
class Dog < Pet
def bark
puts â€œWoof!â€
end
end
â†’ wird nun ein neuer Hund erstellt, kann fÃ¼r diesen die Methode â€œbarkâ€ aufgerufen werden
a_dog = Dog.new
a_dog.bark
# => Woof!  <br><br>
      
      <b>8. SHOES UND RUBY</b> <br> <br>

 Shoes ist ein GUI-Framework fÃ¼r Ruby. GUI steht fÃ¼r â€graphical user interfaceâ€œ und ist eine grafische BenutzeroberflÃ¤che, mit denen User in Programmen interagieren kÃ¶nnen. Framework bedeutet â€GerÃ¼stâ€œ und man kann es als Vorprogrammierung verstehen. So sind in Shoes schon Funktionen und Elemente vorhanden und mÃ¼ssen nicht jedes Mal neu programmiert werden. Shoes kann auf verschiedene Weise verwendet und eingebunden werden. Shoes ermÃ¶glicht es also, fÃ¼r Ruby Programme eine graphische BenutzeroberflÃ¤che zu erstellen. Somit kann der Nutzer einfach mit einem Spiel/einer Webseite oder Ã¤hnlichem interagieren.
Shoes.app do
â€¦
â€¦
end
bildet das GrundgerÃ¼st im Ruby Programm
â†’ wird etwas nach dem â€œendâ€ geschrieben, wird es zwar in Ruby ausgefÃ¼hrt, in Shoes aber nicht<br><br>

      <b>ERSTE SHOES ANWENDUNG</b><br>

â†’ Textausgaben Ã¼ber puts und print sind nicht mehr mÃ¶glich, anstatt davon gibt es aber â€œparaâ€
â†’ para = kurz fÃ¼r Paragraph  <br><br>
      
      <b>9. FLOWS UND STACKS</b><br><br>

Flows und Stacks sind Boxen, Ã¤hnlich wie â€œ
undâ€ in HTML.
Stacks kann man sich wie zusammengebundene Dominosteine vorstellen. Legt man mehr Dominosteine auf einen Stapel, so wird der Stapel einfach hÃ¶her.
Ein Flow dagegen ist eher wie eine Streichholzschachtel. FÃ¼llt man mehr StreichhÃ¶lzer hinein quetschen sich die HÃ¶lzchen einfach zusammen, damit sie irgendwie in die Schachtel passen. Auch in einer Streichholzschachtel kann der untergeordnete Teil â€œhÃ¶herâ€ werden, aber davor ordnen sich die StreichhÃ¶lzer nebeneinander an.
â†’ Das Hauptfenster das mit â€œShoes.appâ€ geÃ¶ffnet wird, ist ein Flow. Man kann auch fÃ¼r Flows und Stacks eine HÃ¶he und Breite festgelegt werden. Ein Beispiel dafÃ¼r kÃ¶nnte so aussehen:
Shoes.app do
stack width: 1.0, height: 1.0
do
background blue
end
end  <br><br>
      
      <b> 10. ZEICHNEN MIT SHOES</b><br><br>

Das Shoes Fenster kann man sich als Koordinatensystem mit einer x- und einer y-Achse vorstellen.
Dabei stellt die Ecke oben links den Nullpunkt dar.
Mit dem Befehl â€œleftâ€ wird immer die x-Achse angesprochen. Umso hÃ¶her der left-Wert umso weiter rechts befindet sich das Element.
Mit â€œtopâ€ kÃ¶nnen die Elemente auf der y-Achse verschoben werden. Umso hÃ¶her der top-Wert, desto tiefer rutscht das Element. <br><br>
      <b> 11. INTERAKTION MIT DEM NUTZER EINBAUEN</b><br><br>

      <b>BUTTONS</b><br>

Eine der am hÃ¤ufigsten genutzten Interaktionen mit dem Nutzer ist ein Button:
Shoes.app do
button â€œWas macht Shoes?â€ do
alert â€œalles farbig und beweglichâ€
end
end<br>
â†’ â€œbuttonâ€ bedeutet: jetzt kommt ein Button<br>
â†’ in den Hochkommata steht, was auf dem Button geschrieben sein soll<br>
â†’ was zwischen dem do und dem end steht, ist das was passieren soll, wenn auf den Button geklickt wird<br> <br>
      <b> 12. FAZIT</b><br><br>

Programmieren war bis zu diesem Semester etwas ganz Unbekanntes fÃ¼r mich. Nie hÃ¤tte ich gedacht, dass ich auch nur ansatzweise in BerÃ¼hrung damit kommen wÃ¼rde, und es Ã¼berhaupt kapieren wÃ¼rde. Wo ich jetzt aber am Ende des Kurses angelangt bin, muss ich sagen, dass ich es eigentlich sogar sehr interessant fand. Ich hatte meine HÃ¶hen und Tiefen, die Erfolgserlebnisse wenn etwas funktioniert hat, waren immer sehr schÃ¶n, aber ehrlich gesagt denke ich, dass die Frustration doch sehr hoch war. Oft haben Aufgaben nicht funktioniert, da sie im Ruby Kurs falsch dargestellt wurden, oder weil der Editor im Kurs nicht funktionierte. Dies fand ich echt schade, da ich deshalb oft schnell an mir selber gezweifelt habe, und dem Aufgeben immer sehr Nahe war. Zum GlÃ¼ck habe ich aber eine gewisse Menge an Ehrgeiz in mir, dass ich immer so lange an Aufgaben dran saÃŸ, bis ich sie endlich â€“ mit oder ohne Hilfe von anderen â€“ schaffen konnte.
Das Prinzip vom Flipped Classroom hat mir persÃ¶nlich nicht so zugesagt, da man, wenn man den Kurs einmal nicht rechtzeitig gemacht hat, nur sehr schwer mitgekommen ist. Dennoch haben mir die PrÃ¤senztermine immer etwas gebracht, da auch oft Ã¤ltere Themen wiederholt wurden.
Im GroÃŸen und Ganzen kann ich sagen, dass ich meine Ruby ProgrammierfÃ¤higkeiten als gut einstufen wÃ¼rde, was fÃ¼r mich persÃ¶nlich als Neuling, eine tolle Erfahrung ist!<br><br>
         
      <h2 class="Fundamentale Ideen der Informatik">Fundamentale Ideen der Informatik</h2>
      <p class="Fundamentale Ideen der Informatik"> <b>1. FUNDAMENTALE IDEEN UND BEGRIFFSERKLÃ„RUNG</b> <br><br>
Fundamentale Ideen sind die grundlegenden Prinzipien, Denkweisen und Methoden der Informatik.
Man unterscheidet hierbei verschiedene Kriterien.</p>
Das Horizontalkriterium beschreibt, dass Fundamentale Ideen eine umfassende Anwendbarkeit in allen Bereichen besitzen, und eine Vielzahl von PhÃ¤nomenen ordnen und integrieren.     
Das Vertikalkriterium beschreibt, dass Fundamentale Ideen innerhalb eines Anwendungsbereiches auf jeder intellekturellen Ebene aufgezeigt werden. Die Unterschiede kÃ¶nnen dann in der Tiefe und Detaillierung ersichtlich werden. Ein Beispiel dafÃ¼r ist, dass Mathematik sowohl in der Schule, als auch in UniversitÃ¤ten gelehrt wird, aber auf unterschiedlichen Niveaus.
Das Zeitkriterium beschreibt, dass die Idee das Ergebnis einer lang andauernden Beobachtung einer Wissenschaft ist, und lÃ¤ngerfristig relevant bleibt.
Das Sinnkriterium beschreibt, dass die Idee im Bezug zur alltÃ¤glichen Sprache und Denken hat, und vortheoretisch unwissenschaftlich ist.<br><br>
      
      <b>Anwendungsbeispiel:</b><br>

â€œIst das Bedienen einer Tastatur eine fundamentale Idee?â€
Horizontal:
Ja, da man diese in mehreren Anwendungsbereichen verwenden kann â€“ bspw. im Internet, Spiele, Bearbeitungsprogramme, an unterschiedlichen GerÃ¤ten, etc.
Vertikal:
Ja, weil es egal von wem genutzt werden kann
Zeitkriterium:
Nein, da es auch schon alternative LÃ¶sungen zu Tastaturen, wie Sprachsteuerung, gibt.
Sinnkriterium:
Ja, aber dies kann sich in den kommenden Jahren auch Ã¤ndern. <br><br>

      <b>EIN PROGRAMMABLAUF</b>
...ist die Verfolgung der Instruktionen eines Programms.<br>
â†’ jede Instruktion kann Speicher lesen, Nebeneffekte haben (PeripheriegerÃ¤te, Speicher schreiben) und den Lauf beeinflussen (bedingt oder wiederholte Teile)<br><br>
   <b>INFORMATIONSPROZESSE</b><br>
Informationen sollen modelliert werden kÃ¶nnen
Mit Hilfe einer hÃ¶heren Programmiersprache
Frage: Wie werden diese Informationen reprÃ¤sentiert und verarbeitet?
Werden visualisiert
ReprÃ¤sentationen werden visuell dargestellt
AblÃ¤ufe werden als Animationen dargestellt <br><br>
 
<b>CODE DEBUGGEN</b> <br> 
Das Programm hat verschiedene Schnittstellen und Knoten
Wenn in einem Knoten ein Fehler vorliegt, dann kann oft der Rest nicht ausgefÃ¼hrt werden
Ã¤hnlich wie bei Stromkreis
Jetzt muss man den Bug (engl. KÃ¤fer) â‰ˆ Fehler finden
Dies kann geschehen, indem man den Fehler visuell darstellt
bei ruby: debug(â€Halloâ€œ)
Diesen Debug stellt man dann an den Knotenpunkt, wo der Fehler vorliegen kÃ¶nnte und testet ob das Programm an dieser Stelle lÃ¤uft oder nicht <br><br>     
      
      <b>2. VERSIONIERUNG</b><br><br>
 â†’ Versionierung ist ein System, das erlaubt, mehrere Versionen einer Datei oder eines Verzeichnisses zu synchronisieren und von verschiedenen Devices darauf zuzugreifen und es zu bearbeiten.<br>
â†’ Versionierung ist ein System, das paralleles Arbeiten an einer Datei oder an einem Verzeichnis erlaubt<br>
â†’ Versionierung ist ein System, das mehrere Versionen synchronisiert<br>
â†’ Versionierung ist ein System, das einen Arbeitsfluss zwischen mehreren Leuten erlaubt<br>
Beispiele hierfÃ¼r sind: GoogleDocs, Moodle, etc.<br> <br> 

      <b>WIESO BRAUCHT MAN VERSIONIERUNG?</b><br>
Situation
â†’ Person A erstellt ein Dokument (Version 1) und schickt das beschriebene Dokument an Person B weiter.<br>
â†’ Person B mÃ¶chte noch etwas abÃ¤ndern und fÃ¼gt noch einige weitere Informationen hinzu (Version 1.1) und schickt es dann an Person C weiter<br>
â†’ Auch Person C Ã¤ndert einige Dinge ab (Version 1.2)<br>
Problem<br>
â†’ Person C muss die neuste Version (Version 1.2) jetzt an zwei verschiedene Personen weiterleiten<br>
â†’ Person A und Person B wissen somit auch nicht, was Person C alles verÃ¤ndert hat<br>
â†’ sehr schwieriges zusammenarbeiten<br>

LÃ¶sung<br>
â†’ Prinzip der Versionierung: Jede Person hat die aktuelle Version als Kopie und kann somit alle Ã„nderungen der anderen personen mitverfolgen/sehen und somit direkt angezeigt bekommen, wer wann was verÃ¤ndert hat.<br><br>
      

      <b>VERSIONIERUNGSPROZESS </b><br>

1. Basic Checkins<br>
einfache BeitrÃ¤ge werden hinzugefÃ¼gt
eine Datei wird stÃ¤ndig verÃ¤ndert und gespeichert
fÃ¼r alle partizipierenden Personen sichtbar/bearbeitbar   <br><br>

      2. Checkout & Edit<br>
eine andere Person macht eine lokale Kopie<br>
Ã„nderungen werden an der Arbeitskopie vorgenommen und dann wieder eingecheckt<br>
er kann die Unterschiede berechnen (diffs) +Eggs +Soup<br>
Konflikte kÃ¶nnen auftreten <br>  <br>   
      
3. Branching<br>
unabhÃ¤ngige Arbeiten kÃ¶nnen auf unterschiedlichen Ã„sten (branches) stattfinden
Im Server gibt es zwei unterschiedliche Reihen von Diffs  <br><br>
    
 4. Merging<br>
      zwei parallele Branches zusammen bringen (Ã„ste werden wieder zusammengefÃ¼hrt) <br> <br>
      
      <b>VERTEILTE ODER ZENTRALE VERSIONIERUNG    </b><br> <br>
Zentrale Versionierung<br>
â†’ altes Vorgehen <br>
â†’ alle Commits sind auf einem Repository<br>
â†’ Konsistenz gesichert, aber Konflikte und Datenverlust<br>br>
Vertikale Versionierung
â†’ modernes Vorgehen<br>
â†’ mehrere Repositories<br>
â†’ jeder kann einen eigenen Server haben<br>
â†’ Commits kÃ¶nnen erst auf lokalem Repository gemacht werden, erst spÃ¤ter wird dann â€gepulltâ€œ<br>
â†’ Diffs (eigentlich Commits) sind Punkt-zu-Punkt vermittelt (Push, Pull)<br>
â†’ wechselseitiger Zugriff auf Repositories<br>
â†’ mÃ¶glich: Firmeninterner Austausch, eigene Branches, parallele Entwicklungen mÃ¶gich, vorherige Versionen kÃ¶nnen wiederhergestellt werden, aber Speicherplatzbedarf<br>
Versionierung: eine fundamentale Idee?<br>
Horizontal:<br>
â†’ verschiedene Anwendungsfelder wie Grafik, Extranets, Entwicklung, Wikisâ€¦br>
Vertikal:<br>
â†’ Kinder malen zusammen mit Kreiden am Boden<br>
â†’ Studenten arbeiten an einem Word Dokument<br>
Zeit:<br>
â†’ rcs und cvs seit den 90ern<br>
â†’ GitHub als groÃŸer Betreiber der Entwicklung<br>
GITHUB<br>
Kooperieren mit GitHub <br>
Git: Software zur Versionierungsverwaltung (von L Torvalds)
Code kann stÃ¤ndig aktualisiert werden, den man bekommen hat
man kann auch vorherige Versionen Ã¶ffnen â€”> speichert jede Art von VerÃ¤nderung
Entwickler reichen Ã„nderungen ein (durch Kommandozeile)
GitHub stellt diese Ã„nderungen ausfÃ¼hrlich auf zugehÃ¶rigen Webseite dar
Alle Operationen durch das Git Programm
â†’ Checkout, Commits, Push, Pull<br>

GitHub als Webanzeige<br>
â†’ und als Editierungswerkzeug, Freies Login<br>
â†’ Freie Verwendung solange es Open-Source bleibt<br>
Forken mit GitHub<br>
Forken (Aufgabelung): Entwicklungszweig nach der Aufspaltung eines Projekts in zwei oder mehrere Folgeprojekte
Jedes lesbare Repository (Ablage) kann geforkt werden<br>
In der Praxis:<br>
â†’ registrieren<br>
â†’ Repo finden, Fork Knopf<br>
â†’ Checkout, VerÃ¤nderungen, Commit, Push<br>
â†’ Pull Request<br><br>
      <b>Pull Request </b><br>
Feature, welches Entwickler nutzen, um die Zusammenarbeit zu erleichtern
bieten eine benutzerfreundliche WeboberflÃ¤che, um CodeÃ¤nderungen zu diskutieren, bevor sie ins offizielle Projekt integriert werden
Mechanismus, mit dem Entwickler Teammitglieder Ã¼ber die Fertigstellung eines Features informieren kann
Sobald sein Feature-Branch soweit ist, setzt er Ã¼ber seinen Bitbucket-Account ein Pull-Request ab â†’ alle Beteiligten wissen dann, dass der Code reviewt und in den Master-Branch gemergt werden muss<br><br>
 
      <b>3. BETRIEBSSYSTEME</b> <br><br>

      <b>Operating System (OS)</b><br>
Zusammenfassung von Computerprogrammen, welche die Systemressourcen eines Computers regeln
Darunter zÃ¤hlen unter anderem Arbeitsspeicher, Festplatten und die Ein- und AusgabegerÃ¤te (Tastatur, Bildschirm)
Ein Betriebssystem verwaltet die genannten Punkte und stellt Anwendungsprogramme zur VerfÃ¼gung
Schnittstelle zwischen der Anwendungssoftware des Nutzers und der Hardware
verfÃ¼gen Ã¼ber graphische BenutzeroberflÃ¤che (graphical user interface â†’ GUI)
ist auf der Festplatte abgelegt <br> <br>    
      
      <b>WIE MACHT MAN EIN PROGRAMM LAUFFÃ„HIG?</b><br>

Programmquellcode muss kompiliert werden
â†’ Umwandlung von Programmcode in ausfÃ¼hrbaren Code
Laufumgebung (Compiler) interpretiert die Kompilierung
notwendig: Quellcode und ein Compiler<br><br>
      <b>IDEE EINER BIBLIOTHEK</b><br>
Application Programming Interface
Schnittstelle zur Anwendungsprogrammierung
arbeitet auf Quelltextebene anders als die BinÃ¤rschnittstellen (ABI)
VerstÃ¤ndigung zwischen 2 Softwareprodukten ohne Eingabe von dem Anwender.
dient zur Anbindung an das Softwaresystem
Zugriff auf Datenbanken oder Hardware wie Festplatte/Graphikkarte
Ein StÃ¼ck Programmcode, welches dazu dient, dass ein Programm automatisiert angesprochen werden kann<br><br>
 
      <b>API ERKLÃ„RT</b><br>

 https://www.youtube.com/watch?v=qW1qhb8r8xI<br><br>

      <b>VON NEUMANN ARCHITEKTUR</b><br>
Komponenten:<br>
CPU<br>
Rechenwerk (ALU = arithmetisch-logische Einheit)
â†’ Das Rechenwerk fÃ¼hrt arithmetische und vergleichende Operationen aus und sorgt fÃ¼r den Transport von Operanden in den und aus dem Hauptspeicher.
Steuerwerk (CU = control unit)<br>
â†’ Das Steuerwerk ermittelt zur Laufzeit die auszufÃ¼hrende Befehlsfolge und sorgt fÃ¼r deren AusfÃ¼hrung.<br>
E/A-Werk<br>
â†’ steuert die Ein- und Ausgabe von Daten<br>
â†’ Tastatur, Bildschirm<br>
Hauptspeicher
â†’ besteht aus einer Folge von Speicherzellen, die sowohl Befehle als auch Operanden aufnehmen kÃ¶nnen<br>
â†’ dient der Speicherung des aktuellen Programms, der Ãœbernahme von Eingabedaten, der Ãœbernahme von Daten aus einem externen Speicher und der vorÃ¼bergehenden Speicherung von Zwischen- oder Endergebnissen.
Bussystem<br>
â†’ reduziert die Anzahl der â€Wegeâ€œ, die zur Kommunikation der verschiedenen Komponenten nÃ¶tig sind, indem die Kommunikationen auf einem Datenweg zusammengeschlossen werden<br><br>
      
      <b>4. JAVA GRUNDLAGEN, KLASSEN UND OBJEKTE</b><br><br>

      <b>WAS IST INTELLIJ IDEA?</b><br>
â†’ eine integrierte Entwicklungsumgebung fÃ¼r die Programmiersprache Java<br>
â†’ entwickelt von dem Unternehmen namens JetBrains<br><br>

      <b>WAS IST JAVA?</b>br>
â†’ eine Scriptsprache<br>
â†’ eine objektorientierte Programmierung<br>
Voraussetzungen:<br>
â†’ Java-Entwicklungswerkzeug (JDK) â†’ Erstellung von Java Programmen<br>
â†’ Java-Laufteizumgebung (JRE)<br>
virtuelle Maschine (JVM) und Bibliotheken â†’ AusfÃ¼hrung von Java Programmen<br>
Funktionsweise:<br>
â†’ Quellcode in der Scriptsprache Java schreiben<br>
â†’ Quellcode wird von Compiler in Bytecode umgewandelt (von Programmiersprache in Maschinensprache)<br>
â†’ JVM (virtuelle Maschinen) werden eingesetzt â†’ interpretiert den Bytecode und fÃ¼hrt Programm aus<br>
â†’ Je nach Betriebssystem, muss auch eine bestimmte virtuelle Maschine installiert sein, damit das Programm beliebig auf jedem Betriebssystem ausgefÃ¼hrt werden kann<br><br>

 <b>KLASSEN </b><br>
â†’ strukturiert die Programme <br>
â†’ besteht aus Attributen und Methoden<br>
â†’ Verallgemeinerung von Objekten<br>
â†’ beschreibt, was fÃ¼r Attribute ein Objekt haben kann, weist ihr aber keinen Wert zu<br>
â†’ genauere Beschreibung und Wertzuweisung gibt es erst beim Objekt<br><br>
      <b>BEISPIEL</b><br>
Mensch mit Eigenschaften wie Augenfarbe, Geschlecht, GrÃ¶ÃŸe und Funktionen wie Sprechen, jedoch weiÃŸ man noch nicht welche Werte diese Eigenschaften haben<br><br>

      <b>OBJEKTE</b><br>
â†’ genauere Beschreibung eines Dinges aus der RealitÃ¤t<br>
â†’ bestimmte Attribute (Eigenschaften), mit einem bestimmten Wert (der jeweiligen Klasse)<br>
â†’ sind nicht immer greifbare Dinge, sondern auch Datenstrukturen<br>
â†’ jedes Objekt ist einer Klasse zugehÃ¶rig<br>
â†’ Klasse Mensch kann viele Objekte haben â†’ 7,5 Milliarden Objekte insgesamt auf der Welt<br><br>

      <b>BEISPIEL </b>

Objekt = Amina Serdarevic
Augenfarbe = graublau
Haarfarbe = dunkelblond
GrÃ¶ÃŸe = 1,75 m
Geschlecht = weiblich
Sprache = bosnisch<br><br>

      <b>ATTRIBUTE</b><br>

â†’ Eigenschaft eines Objekts einer Klasse<br>
â†’ hat einen bestimmten Wert<br>
â†’ Bsp. Geschlecht = weiblich<br><br>

      <b>SUBKLASSEN</b><br>

â†’ ist eine Klasse, deren Objekte zu einer anderen Klasse gehÃ¶ren<br>
â†’ alle Klassen sind Subklassen von Objekten, sie haben:<br>
â†’ eine toString Methode, um in der Konsole gedruckt zu werden<br>
â†’ eine equals Methode, um mit anderen verglichen zu werden<br><br>

      <b>METHODEN</b><br>

â†’ werden mit einem Namen aufgerufen <br>
â†’ kann einen Wert zurÃ¼ckgeben<br>
â†’ um Variablen zu isolieren, um Wiederholungen zu vermeiden<br>
â†’ Interaktionene, die man an einem Objekt durchfÃ¼hren kann (z.B. sprechen), nennt man Methoden<br>
â†’ Funktionen und Verhaltensweisen<br>
â†’ greift auf Eigenschaften eines Objekts zu<br>
â†’ Attribute kÃ¶nnen verÃ¤ndert werden, Attributwerte kÃ¶nnen abgefragt werden<br>
â†’ Eigenschaften kÃ¶nnen auch zwei ZustÃ¤nde haben (z.B. bei einem Lichtschalter an/aus)<br>
â†’ durch Methoden kann abgefragt werden, ob eine bestimmte Eigenschaft zutrifft (true) oder nicht (false)<br>
â†’ Methoden kÃ¶nnen:<br>
â€“ private sein und sind nur in der Klasse sichtbar<br>
â€“ protected sein und somit auch in den Subklassen und im Package sichtbar sein<br>
â€“ default sein und damit im Package sichtbar<br>
â€“ public sein und so von Ã¼berall erreichbar<br><br>

      <b>VARIABLEN</b><br>

â†’ BehÃ¤lter fÃ¼r einen verÃ¤nderlichen Inhalt<br>
â†’ Platzhalter fÃ¼r Daten<br>
â†’ arithmetische Operationen (rechnen)<br>
â†’ mÃ¼ssen immer sinnvoll benannt werden (Codelesbarkeit)<br><br>

      <b>DATENTYPEN</b><br>
â†’ bei jeder Deklaration einer Variable muss auch ihr Datentyp angegeben werden<br>
â†’ variable wird erst deklariert anschlieÃŸend wird ein Wert zurÃ¼ckgegeben<br>

int = tee;
tee = 250;Mit System.out.printIn(tee); kann die Variable ausgegeben werden
Anzeige: 250 <br><br>

      <b>5. SUCHMASCHINEN</b><br><br>
Eine Suchmaschine ist ein Programm zur Recherche von Dokumenten, die in einem Computer oder einem Computernetzwerk wie z. B. dem World Wide Web gespeichert sind. Internet-Suchmaschinen haben ihren Ursprung in Information-Retrieval-Systemen. Sie erstellen einen SchlÃ¼sselwort-Index fÃ¼r die Dokumentbasis, um Suchanfragen Ã¼ber SchlÃ¼sselwÃ¶rter mit einer nach Relevanz geordneten Trefferliste zu beantworten. Nach Eingabe eines Suchbegriffs liefert eine Suchmaschine eine Liste von Verweisen auf mÃ¶glicherweise relevante Dokumente, meistens dargestellt mit Titel und einem kurzen Auszug des jeweiligen Dokuments. Dabei kÃ¶nnen verschiedene Suchverfahren Anwendung finden.<br><br>

      <b>AUFGABEN</b><br>
â†’ Erstellen und Pflege von Datenstrukturen mit Informationen Ã¼ber Dokumente<br>
â†’ Verarbeiten von Suchanfragen<br>
â†’ Aufbereitung der Ergebnisse (meist nach Relevanz sortiert) <br><br>
      
      
      <b>  6. DATENSTRUKTUREN</b><br><br>
Eine Datenstruktur ist ein Objekt zur Speicherung und Organisation von Daten. Es handelt sich um eine Struktur, weil die Daten in einer bestimmten Art und Weise angeordnet und verknÃ¼pft werden, um den Zugriff auf sie und ihre Verwaltung effizient zu ermÃ¶glichen.
LINKED LIST <br>
â†’ LinkedList (java.util.LinkedList), wird im Deutschen auch als Verkettete Liste bezeichnet<br>
â†’ jedes Element hat einen Nachfolger links und einen rechts<br>
â†’ Bei einer LinkedList stehen alle Listenelemente in Verbindung zum jeweiligen VorgÃ¤nger bzw. Nachfolger<br>
â†’ Existiert kein Nachfolger, so verweist das letzte Element auf die null-Referenz.<br>
â†’ Der Vorteil bei einer Verketteten Liste besteht darin, dass im Vergleich zu einer ArrayList die Elemente schneller hinzugefÃ¼gt und gelÃ¶scht werden kÃ¶nnen â†’ Verweise auf Nachbarn mÃ¼ssen geÃ¤ndert werden<br>
â†’ Element der Liste an einer bestimmten Stelle auslesen â†’ Zugriff langsamer, da Verbindungen bis zu passenden Element durchlaufen werden muss<br>
â†’ Entscheidung fÃ¼r einen bestimmten Listen-Typ sollte von der Art und Anzahl der Zugriffe abhÃ¤ngig gemacht werden<br>

Linked List is a data structure consisting of a group of vertices (nodes) which together represent a sequence. Under the simplest form, each vertex is composed of a data and a reference (link) to the next vertex in the sequence. Try clicking Search(77) for a sample animation on searching a value in a (Singly) Linked List.
Linked List and its variations are used as underlying data structure to implement List, Stack, Queue, and Deque ADTs.<br><br>
      
      <b>7. PARALLELITÃ„T</b><br><br>

â†’ wenn mehrere Prozesse in einem Netzwerk oder Core laufen<br>
â†’ Beispiel: Steam und Spotify laufen gleichzeitig<br>
Im Modell von Neumann gibt es keine ParallelitÃ¤t mit Prozessoren. Ein Schedule also ein AusfÃ¼hrungsplan ist fÃ¼r die vielen DurchfÃ¼hrungen zustÃ¤ndig. Der Schedule gibt zudem noch an, in welcher Reihenfolge die Operationen stattfinden. Unteranderem gehÃ¶ren zu den Operationen Lese- und Schreiboperationen sowie Terminatorenoperationen. Desweiteren macht ein Schedule alle 50ms Unterbrechungen und fÃ¤hrt anschlieÃŸend fort. Wir Nutzer merken dies nicht. Daher sind viele Betriebssysteme multitaskingfÃ¤hig oder interleavingfÃ¤hig. Interleaving ist eine Optimierungstechnik bei der DatenÃ¼bertragung. Dort werden Daten in einer bestimmten Reihenfolge geordnet, um einen hÃ¶heren Datensatz zu bekommen. <br><br>     
    
      <b>8. BENUTZERSCHNITTSTELLEN</b><br><br>

Die Benutzerschnittstelle ist die Stelle oder Handlung, mit der ein Mensch mit einer Maschine in Kontakt tritt. Im einfachsten Fall ist das ein Lichtschalter: Er gehÃ¶rt weder zum Menschen, noch zur â€Maschineâ€œ (Lampe), sondern ist die Schnittstelle zwischen beiden.<br>
â†’ auch Mensch-Maschine-Schnittstelle oder Human-Computer-Interaction genannt <br> <br>

      <b>BESTANDTEILE</b><br>

â†’ Zugang zu Programmen und Dateien wird als Icon (Bildsymbole) dargestellt<br>
â†’ Programme Ã¶ffnen ein Hauptfenster â†’ GUI-System erlaubt, solche Fenster in ihrer GrÃ¶ÃŸe und Position zu verÃ¤ndern, auszublenden oder auf die gesamte BildschirmgrÃ¶ÃŸe zu vergrÃ¶ÃŸern<br>
â†’ Weitere Bedienelemente: SchaltflÃ¤chen (Buttons), Toolbars (Symbolleisten, Werkzeugleisten), Schieberegler, Auswahllisten und Symbole<br>
â†’ Zusammengefasst werden alle diese Elemente zum WIMP-Modell (engl. W fÃ¼r Windows (Fenster), I fÃ¼r Icons (Datei- und Programmsymbole), M fÃ¼r Menu (MenÃ¼) und P fÃ¼r Pointer (Zeiger, der zum Beispiel durch die Maus bewegt wird))<br>
â†’ Eine Palette als GUI-Element ist â€nicht-modalâ€œ und wird oft am Seitenrand angeordnet<br><br>      
      
      <b> 9. NETWORK</b> <br><br>

      <b>NETZWERK</b><br>

â†’ Zusammenschluss von verschiedenen technischen Systemen â†’ ermÃ¶glicht Kommunikation der Systeme untereinander<br>
â†’ Ziel: gemeinsame Nutzung von Ressourcen, wie bspw. Datenbanken, Drucker, Dateien oder Servern<br>
â†’ die Kommunikation verlÃ¤uft Ã¼ber verschiedene Protokolle<br><br>

 <b>IDEE PACKET NETWORK </b><br>   
â†’ ein Netzwerk aus verschiedenen Computern mit verschiedenen Adressen und Routern kÃ¶nnen miteinander kommunizieren<br>
â†’ sie versenden sich gegenseitig verschiedene Datenpakete (Datenpaket ist eine Bezeichnung fÃ¼r in sich geschlossene Dateneinheiten)<br>
â†’ sie besitzen einen Sender und einen EmpfÃ¤nger<br>
â†’ das Meiste in einem Datenpaket besteht aus wichtigen Adressierungs- und
Verwaltungsinformationen, welche von IP-basierten Netzwerken die mit Quelladressen gefÃ¼llt sind an den richtigen Computer liefern<br>
â†’ Solche Informationen befinden sich in einem Header (Header sind die Zusatzinformationen, die Nutzerdaten am Anfang eines Datenblocks ergÃ¤nzen)<br><br>

      <b>SOCKETS</b><br>
â†’ ein Socket ist ein Modul, welches als Kommunikationsendpunkt dient<br>
â†’ Sockets werden verwendet, um Daten mit anderen Programmen auszutauschen<br>
â†’ das Programm kann sich auf dem selben oder einem anderen Computer befinden<br>
â†’ Sockets kÃ¶nnen Daten empfangen und versenden<br>
â†’ sind dafÃ¼r zustÃ¤ndig, dass Daten in der richtigen Reihenfolge versendet werden<br> <br>

      <b>BUFFER</b><br>

â†’ Speicher fÃ¼r die Zwischenlagerung von Daten<br>
â†’ die Daten, welche als erste da sind, werden zuerst empfangen, die anderen befinden sich sozusagen in einer â€œWarteschlangeâ€<br>
â†’ es kÃ¶nnen immer wieder Daten hinzukommen, die sich aber so lange in der Warteschlange befinden, bis sie empfangen werden<br><br>

      <b>10. VERSCHLÃœSSELUNG</b><br><br>

Die VerschlÃ¼sselung ist eine MÃ¶glichkeit, die Sicherheit von Daten zu erhÃ¶hen, indem der Inhalt einer Nachricht oder Datei so unkenntlich gemacht wird, dass sie nur von der Person gelesen werden kann, die Ã¼ber den passenden VerschlÃ¼sselungsschlÃ¼ssel verfÃ¼gt.  
Die Grundidee der VerschlÃ¼sselung ist es, wie oben dargestellt wird, eine Nachricht von A nach B zu verschicken, ohne dass C die Nachricht sehen kann. So wie mit Postkarten, welche nicht â€verschlÃ¼sseltâ€œ sind und der â€3.â€œ sie eventuell lesen kann, im Falle der Postkarte der Postbote. Durch VerschlÃ¼sselung wird dies verhindert. Um einen verschlÃ¼sselten Text zu lesen, muss man â€nurâ€œ den SchlÃ¼ssel besitzen. Wenn man diesen hat, ist das LÃ¶sen der VerschlÃ¼sselung nicht mehr schwer. <br><br>     
      
      <b>  11. KOMPRIMIERUNG </b><br><br>

Die Datenkompression â€“ auch Datenkomprimierung genannt â€“ ist ein Vorgang, bei dem die Menge digitaler Daten verdichtet oder reduziert wird. Dadurch sinkt der benÃ¶tigte Speicherplatz und die Ãœbertragungszeit der Daten verkÃ¼rzt sich.
Es werden zwei Arten von Komprimierung unterschieden, nÃ¤mlich die verlustfreie und die verlustbehaftete Komprimierung.
Die verlustfreie Komprimierung kann zurÃ¼ck in ihren Originalzustand gebracht werden, ist also reversibel.
Die verlustbehaftete Komprimierung hingegen kann nicht in ihren Originalzustand gebracht werden, da Daten verloren gehen. <br><br>
 <b>HUFFMAN CODIERUNG</b><br>
Die Huffman-Kodierung ist eine Form der Entropiekodierung, die 1952 von David A. Huffman entwickelt wurde um eine verlustlose Kompression zu ermÃ¶glichen.
Prinzip: Statt jedem Wort einen gleichlangen Code zuzuordnen, bekommen Zeichen, die hÃ¤ufig im Text vorkommen einen kÃ¼rzeren Code als seltene Zeichen.
Hilfsmittel: CodebÃ¤ume, mit denen sich CodewÃ¶rter grafisch als Baum darstellen lassen. Den Code eines Zeichen liest man aus dem Codebaum ab, indem man von unten (also der Wurzel des Baumes) bis zum gesuchten Zeichen am Ende des Baumes wandert und die dabei gefundenen Beschriftungen an den Verzweigungen notiert.<br><br>  
   
      <b> 12. MASCHINELLES LERNEN</b><br><br>

 Maschinelles Lernen lÃ¤sst sich als Teilgebiet der kÃ¼nstlichen Intelligenz betiteln. Hierbei wird Lernen als: â€[â€¦] ein Prozess [dargestellt], der zu einer Performanzsteigerung eines Systems fÃ¼hrt.â€œ
Das System ist hierbei der Computer, oder der Mensch und die Performanzsteigerung stellt die VerhaltensÃ¤nderung im Hinblick auf die Optimierung einer Bewertungsfunktion dar.
Ein kÃ¼nstliches System lernt aus Beispielen und kann nach Beendigung der Lernphase verallgemeinern. Es lernt dabei nicht einfach Beispiele auswendig, sondern es erkennt GesetzmÃ¤ÃŸigkeiten in den Lerndaten. So kann das System auch unbekannte Daten beurteilen.<br><br>

      <b>INDUKTIVES LERNEN</b><br>
= aus dem Speziellen, das Allgemeine lernen<br>
â†’ die Idee ist die, dass man eine Funktion aus Beispielen lernen soll und mithilfe von gegebenen Fakten, Hypothesen aufstellt<br>
Ablauf: Funktion finden â‡’ Funktion passt fÃ¼r mÃ¶glichst viele Beispiele â‡’ Funktion wird verallgemeinert<br>

      BEISPIEL:<br>
Gegeben: Schwimmt (Forelle), Schwimmt (Karpfen)<br>
Folgerung: Schwimmt (Fisch)<br>
â†’ Vom Spezifischen auf das Allgemeine<br><br>

      <b>LATENT SEMANTIC ANALYSIS</b><br>
= Verfahren der automatischen Sprachverarbeitung<br>
â†’ dient also dazu, um Ã„hnlichkeiten zwischen unterschiedlichen AusdrÃ¼cken zu errechnen<br>

Ziel: die generellen Begriffe eines Dokumentes zu finden<br>
Idee: WÃ¶rter, die hÃ¤ufig im Dokument vorkommen, haben eine latent Ã¤hnliche Bedeutungen<br><br>

      <b>BEISPIEL:</b><br>
â†’ aus sehr viele Daten (z.B. im Internet) sollen diejenigen gefunden werden, in denen das Wort Auto vorkommt<br>
â†’ auch diejenigen, in denen es um das Thema Auto geht, aber der Name nicht explizit im Dokument genannt wird<br>
â†’ kann Dokumente unterscheiden, in denen es wirklich um Autos geht und in denen nur das Wort Auto vorkommt (wie zum Beispiel Gewinnspiele)<br><br>

      <b>FUNKTIONSWEISE:</b><br>
â†’ Worterscheinung werden als Matrix gesammelt<br>
â†’ in Spalten werden die Erscheinungsmengen der WÃ¶rter gesammelt<br>
â†’ in den Reihen die Dokumente     <br><br>

      <b>13. FAZIT</b> <br><br>

Meine Erfahrungen mit dem Kurs Fundamentale Ideen der Informatik waren eher negativ, da meine Kohorte den Kurs aufgrund von AusfÃ¤llen nur sehr selten besuchen konnte. AuÃŸerdem haben wir auch kein Folien von Herrn Beer zur VerfÃ¼gung gestellt bekommen, weshalb ich mit den Materialien von Herrn Libbrecht gearbeitet habe. Aufgrund von einer sprachlichen Barriere fiel es mir sehr schwer etwas zu verstehen, weshalb ich mich oft auf eigene Recherchen bezogen habe. Dadurch konnte ich das E-Portfolio dann aber vervollstÃ¤ndigen und nachvollziehen.     
      
      <h1 class="Schwerpunkte">Schwerpunkte</h1>
      <p class="Schwerpunkte">Unter diesem Reiter finden Sie meine beiden Schwerpunkte zu den Vorlesungen â€Programmieren in einer objektorientierten Umgebungâ€œ und â€Fundamentale Ideen der Informatikâ€. Viel SpaÃŸ beim DurchstÃ¶bern! ğŸ™‚</p>
      
      <h2 class="Programmieren in einer objektorientierten Umgebung â€“ Schwerpunkt">Programmieren in einer objektorientierten Umgebung â€“ Schwerpunkt</h2> 
      <p class="Programmieren in einer objektorientierten Umgebung â€“ Schwerpunkt"> <b>HERO TROUBLE</b> <br><br>
          <b> EINFÃœHRUNG</b> <br><br>
Ich habe zusammen mit meiner Gruppe, mit Sophia Pournaras, Stefan Maisch und Tim Reisenauer, das Spiel â€œHero Troubleâ€ entwickelt. Unser Spiel basiert auf dem bereits vorhandenem Spiel â€œTank Troubleâ€ (https://www.tanktrouble.com), in dem es darum geht den bzw die gegnerischen Panzer abzuschieÃŸen. Dabei befinden sich die einzelnen Panzer an verschiedenen Stellen in einem Labyrinth. Es ist mÃ¶glich dieses Spiel alleine gegen einen Computer, zu zweit oder zu dritt zu spielen. </p>
Bei unserem Spiel, â€œHero Troubleâ€, handelt es sich um ein sehr Ã¤hnliches Konzept. Es ist als Zwei-Spieler-Spiel konzipiert, und es geht darum, dass Superman (Spieler 1) und Batman (Spieler 2) sich gegenseitig abschieÃŸen, bzw sich nicht abschieÃŸen lassen. Diese befinden sich auch in einem Labyrinth, welches Hindernisse beziehungsweise Begrenzungen darstellt.<br><br>    
      <b>KONZEPTION</b><br><br>
Nachdem wir uns auf eine Spielidee geeinigt haben, ging es fÃ¼r uns an die Arbeit. Zuerst begaben wir uns auf die Suche nach Spielfiguren. Schnell haben wir die Illustrationen von Batman und Superman (https://img.etsystatic.com/il/c6033d/1347625235/il_fullxfull.1347625235_o26v.jpg) gefunden und uns fÃ¼r diese entschieden. Daraufhin haben wir diese mit Photoshop zurecht geschnitten und uns dem Aufbau des Startfensters und des Labyrinths gewidmet. Diese Aufgaben haben wir aufgeteilt, zwei von uns entwickelten das Labyrinth und die anderen beiden schrieben den ersten Teil des Codes fÃ¼r das Startfenster. Auf den genauen Code werde ich unter dem Punkt â€œUmsetzungâ€ zurÃ¼ckkommen.
Um die Koordinaten leichter festlegen zu kÃ¶nnen, haben wir das Labyrinth direkt in einem Koordinatensystem gezeichnet. Die obere, linke Ecke lag dabei nicht im Nullpunkt, sondern bei (100/100). Nachdem wir die Ã¤uÃŸeren Linien festgelegt haben, haben wir nach und nach die im Labyrinth liegenden Linien definiert.<br>
Dies bringt mich auch schon in die Phase der Umsetzung. <br> <br>

      <b>UMSETZUNG </b><br><br>
In dem Programmcode, den ich Ihnen in einer Dropbox zur VerfÃ¼gung gestellt habe, steht schon sehr detailliert, wozu die einzelnen Elemente dienen, weshalb ich hier nur auf besondere Teile des Spielcodes eingehen werde.     
Nach dem Programmkopf, in welchem wir allgemeine Daten, wie den Spielnamen festgelegt haben, haben wir dargestellt, dass wir eine externe Datei einbinden mÃ¶chten. (Auf diese Datei werde ich spÃ¤ter noch einmal zurÃ¼ckkommen).
Als nÃ¤chstes haben wir die Shoes App mit â€œShoes.app doâ€ gestartet und den Titel des Spiels und die nicht verÃ¤nderbare GrÃ¶ÃŸe des Fensters bestimmt.
ZunÃ¤chst haben wir grundlegende Dinge fÃ¼r das Start- und Steuerungsfenster eingestellt. WIrd nun der Button â€œPlayâ€ betÃ¤tigt, beginnt der Hauptteil des Programmcodes.
Als erstes werden die Linien des Labyrinths, von denen ich vorher schon einmal gesprochen habe, aufgerufen.   
Nun werden â€œOvaleâ€, die die Schusspatronen der Spieler darstellen, einmal festgelegt, damit sie beim ersten â€œremoveâ€ Befehl, entfernt werden. Dies dient dazu, dass wenn die Spieler spÃ¤ter schieÃŸen mÃ¶chten, die davor abgeschossene Schusspatrone entfernt (also removed) wird, sobald die nÃ¤chste abgefeuert wurde.
Damit die SchÃ¼sse spÃ¤ter auch funktionieren, werden Sie nun in zwei Funktionen, eine fÃ¼r jeden Spieler, definiert. Innerhalb der Funktionen sind einige Kontrollstrukturen in einander verschachtelt, um jede mÃ¶gliche Bedingung zu erfÃ¼llen. Ebenfalls wird hier definiert, dass Spieler 1 mit der Taste â€œQâ€ und Spieler 2 mit der Taste â€œMâ€ schieÃŸt.      
Danach, haben wir die Startpositionen und die Steuerung der beiden Spielfiguren festgelegt. Auch hier findet man eine Verkettung von mehreren Fallentscheidungen wieder.
Mit einem keypress-Event, werden dann die zuvor festgelegten Kontrollstrukturen, welche, bzw ob eine Taste aufgerufen wird, Ã¼berprÃ¼ft.      
Als letztes wird die zuvor genannte, ausgelagerte Funktion noch aufgerufen. In dieser Funktion, haben wir festgelegt, dass wenn Spieler 1 oder Spieler 2, die Linien des Labyrinths berÃ¼hren, sie diese nicht durchdringen kÃ¶nnen und begrenzt werden. AuÃŸerdem werden sie immer wenn sie eine Linie berÃ¼hrt haben, ein StÃ¼ck weiter in die Mitte des davor genutzten Weges gesetzt.
Die Funktion haben wir deshalb ausgelagert, da sie sehr lang und daher unÃ¼bersichtlich und unstrukturiert wirkt.  <br><br>    
 
      <b>FAZIT</b><br><br>
Zusammenfassend kann ich sagen, dass mir das Programmieren des Spiels mehr Freude als erwartet bereitet hat, da ich vor dieser Vorlesung noch nie in Kontakt mit irgendeiner Art von Programmieren gekommen bin.
Es war stets interessant und fÃ¼r mich persÃ¶nlich auch sehr verlockend, wenn etwas mal nicht funktioniert hat und wir nach der LÃ¶sung suchen mussten, damit alles perfekt lÃ¤uft.
Es hat mir sehr viel Freude bereitet dieses Spiel zu programmieren, und bin sehr stolz sagen zu kÃ¶nnen, dass dies unser Werk ist!
      
      <h2 class="Fundamentale Ideen der Informatik â€“ Schwerpunkt">Fundamentale Ideen der Informatik â€“ Schwerpunkt</h2>
      <p class="Fundamentale Ideen der Informatik â€“ Schwerpunkt"> <b>VERSCHLÃœSSELUNG â€“ ADVANCED ENCRYPTION STANDARD </b><br><br>
          
<b> EINFÃœHRUNG VERSCHLÃœSSELUNG: </b><br> <br>

Unter VerschlÃ¼sselung versteht man Verfahren und Algorithmen, die Daten mittels digitaler bzw. elektronischer Codes oder SchlÃ¼ssel inhaltlich in eine nicht lesbare Form umwandeln. Diesen Vorgang bezeichnet man als VerschlÃ¼sseln. Gleichzeitig wird dafÃ¼r gesorgt, dass nur mit dem Wissen eines SchlÃ¼ssels die geheimen Daten wieder entschlÃ¼sselt werden kÃ¶nnen.
Anstatt von VerschlÃ¼sselung spricht man auch von Chiffrierung, was das gleiche meint.<br><br>
          <b>EINFÃœHRUNG ADVANCED ENCRYPTION STANDARD:</b><br>

Der Advanced Encryption Standard (AES) ist eine Blockchiffre, die als Nachfolger fÃ¼r DES im Oktober 2000 vom National Institute of Standards and Technology (NIST) als Standard bekanntgegeben wurde. Nach seinen Entwicklern Joan Daemen und Vincent Rijmen wird AES auch Rijndael-Algorithmus genannt.
Es handelt sich um ein symmetrisches VerschlÃ¼sselungsverfahren. Der Rijndael-Algorithmus besitzt variable, voneinander unabhÃ¤ngige Block- und SchlÃ¼ssellÃ¤ngen von 128, 160, 192, 224 oder 256 Bit. AuÃŸerdem bietet dieser ein sehr hohes MaÃŸ an Sicherheit; â†’ erst mehr als zehn Jahre nach seiner Standardisierung wurde der erste theoretisch interessante, praktisch aber nicht relevante Angriff gefunden.<br><br>
          
<b>ENTSTEHUNG ADVANCED ENCRYPTION STANDARD:</b><br>
Im Januar 1997 schrieb das amerikanische Handelsministerium eine Suche nach einem Nachfolger des DES-Verfahrens aus, da dieses als VerschlÃ¼sselungsverfahren nicht mehr so gut funktionierte, da es auf eine DatengrÃ¶ÃŸe von 56 Bit beschrÃ¤nkt war. Es wurden folgende Rahmenbedingungen gegeben, die das zukÃ¼nftige AES Verfahren erfÃ¼llen musste:<br>
muss ein symmetrischer Algorithmus sein<br>
muss 128 Bit lange BlÃ¶cke verwenden<br>
muss SchlÃ¼ssel von 128, 192 und 256 Bit LÃ¤nge einsetzen kÃ¶nnen<br>
soll gleichermaÃŸen leicht in Hard- und Software zu implementierbar sein<br>
soll eine Ã¼berdurchschnittliche Leistung haben<br>
soll allen bekannten Methoden der Kryptoanalyse widerstehen kÃ¶nnen, insbesondere Power- und Timing-Attacken<br>
geringe Ressourcen Erforderlichkeit<br>
frei von patentrechtlichen AnsprÃ¼chen sein und muss von jedermann unentgeltlich genutzt werden kÃ¶nnen<br>
Neben Joan Daemen und Vincent Rijmen gab es noch Teilnehmer aus vielen weiteren LÃ¤ndern, die ihre Ideen prÃ¤sentiert haben. Auch Deutschland wurde durch die Deutsche Telekom mit der â€Magentaâ€œ als Idee vertreten. Aufgrund von massiver Sicherheits- und Leistungsprobleme wurde diese dann aber nicht ausgewÃ¤hlt.       
In Bezug auf die drei Hauptkriterien, Kosten, Implementierung und Sicherheit, entschied sich die NIST (National Institute of Standards and Technology) fÃ¼r das Rijndael Verfahren.<br><br>

          <b>ABLAUF:</b><br><br>
Rijndael sind Blockchiffren auf Basis eines Substitutions-Permutations-Netzwerks (SPN). Das Verfahren wechselt bei jedem Schritt zwischen Substitution und Permutation, weshalb man AES auch als SP-Chiffre bezeichnet. Dabei erfolgt die Transformation des Klartextes in mehreren Runden gleichen Aufbaus. Der Klartext wird dabei nicht als Ganzes, sondern in BlÃ¶cken verarbeitet. Hierbei findet eine Konfusion statt, es wird also unter anderem die Beziehung zwischen Klar- und Geheimtext verwischt.
Die BlocklÃ¤nge unterscheidet sich zwischen Rijndael und AES etwas, bei Rijndael kÃ¶nnen die Block- und SchlÃ¼ssellÃ¤nge unabhÃ¤ngig voneinander die Werte 128, 160, 192, 224 oder 256 Bits haben. Bei AES wurde die BlocklÃ¤nge auf 128 Bit und die SchlÃ¼sselgrÃ¶ÃŸe auf 128 (10 Runden), 192 (12 Runden) und 256 Bit (14 Runden), nach den Anforderungen von der NIST, festgelegt.
Die AES-EntschlÃ¼sselung sieht notwendigerweise vor, dass dieselben Schritte wie bei der VerschlÃ¼sselung durchlaufen werden mÃ¼ssen, nur eben in umgekehrter Reihenfolge.
Jeder Block wird zunÃ¤chst in eine zweidimensionale Tabelle mit vier Zeilen geschrieben, dessen Zellen ein Byte groÃŸ sind. Die Anzahl der Spalten variiert je nach BlockgrÃ¶ÃŸe von 4 (128 Bit) bis 8 (256 Bit). Jeder Block wird nun nacheinander bestimmten Transformationen unterzogen. Aber anstatt jeden Block einmal mit dem SchlÃ¼ssel zu Chiffrieren, wendet AES verschiedene Teile des SchlÃ¼ssels nacheinander auf den Klartext-Block an. Die Anzahl dieser Runden (r) variiert und ist von SchlÃ¼ssellÃ¤nge (k) und BlockgrÃ¶ÃŸe (b) abhÃ¤ngig:<br><br>
 
Der weitere Ablauf ist dann in folgende Schritte eingeteilt:<br>

SchlÃ¼sselexpansion<br><br>
Vorrunde<br>
KeyAddition ()<br>
VerschlÃ¼sselungsrunden (wiederhole solange runde<r)<br>
Substitution()<br>
ShiftRow()<br>
MixColumn()<br>
KeyAddition()<br>
Schlussrunde<br>
Substitution()<br>
ShiftRow()<br>
KeyAddition()<br>
â†’ Die Schlussrunde zÃ¤hlt auch als Runde, also R = Anzahl VerschlÃ¼sselungsrunden + 1 Schlussrunde<br><br>

<b>SCHLÃœSSELEXPANSION</b><br>
zunÃ¤chst werden aus dem SchlÃ¼ssel R + 1 TeilschlÃ¼ssel, auch RundenschlÃ¼ssel genannt, erzeugt
Die RundenschlÃ¼ssel mÃ¼ssen die gleiche LÃ¤nge wie die BlÃ¶cke haben
Mathematisch dargestellt heiÃŸt dies dann â€b*(R+1)â€œ wobei b die BlocklÃ¤nge angibt
Der SchlÃ¼ssel wird dann in eine zweidimensionale Tabelle mit vier Zeilen und Zellen, die jeweils 1 Byte groÃŸ sind, abgebildet
Die ersten Spalten werden dann mit dem BenutzerschlÃ¼ssel gefÃ¼llt
Alle weiteren Spalten werden rekursiv berechnet:
Um die Werte fÃ¼r die Zellen in der nÃ¤chsten Spalte zu erhalten, werden die Spalten, welche je nach BlockgrÃ¶ÃŸe ein Vielfaches der vierten, sechsten oder achten Spalte sind, nach links rotiert [a0,a1,a2,a3] wird zu [a1,a2,a3,a0] und mit Hilfe der S-Box verschlÃ¼sselt
Danach wird der â€vordersteâ€œ Wert der Spalte mit der rcon-Tabelle XOR verknÃ¼pft und abschlieÃŸend die gesamte Spalte mit der um eine SchlÃ¼ssellÃ¤nge zurÃ¼ckliegenden Spalte XOR verknÃ¼pft
Alle anderen Spalten werden aus einer XOR-VerknÃ¼pfung mit der Spalte eine SchlÃ¼ssellÃ¤nge vorher gebildet
Eine Ausnahme bildet AES-256
Hierbei wird jede 4. Spalte durch die S-Box ersetzt und dann mit der Spalte eine SchlÃ¼ssellÃ¤nge davor XOR-verknÃ¼pft <br> <br>          
          
          <b>ADDROUNDKEY</b><br><br>

Die KeyAddition wird in der Vorrunde und am Ende jeder anderen VerschlÃ¼sselungsrunde ausgefÃ¼hrt
Hier wird eine bitweise XOR-VerknÃ¼pfung zwischen dem Block und dem aktuellen RundenschlÃ¼ssel vorgenommen
Dies ist die einzige Funktion in AES, die den Algorithmus vom BenutzerschlÃ¼ssel abhÃ¤ngig macht<br> <br>
 

          <b>SUBBYTES</b> <br><br>

Im ersten Schritt jeder Runde wird fÃ¼r jedes Byte im Block ein Ã„quivalent in der S-Box gesucht
so werden die Daten monoalphabetisch verschlÃ¼sselt<br><br>
 

          <b>SHIFTROWS</b><br><br>

In diesem Schritt werden die Zeilen um eine bestimmte Anzahl von Spalten nach links verschoben
Ãœberlaufende Zellen werden von rechts fortgesetzt
Die Anzahl der Verschiebungen hÃ¤ngt von den Block und ZeilenlÃ¤ngen ab
Die Zeile wird entweder um 1 bis 4 Spalten verschoben <br><br>        
 
          <b>MIXCOLUMN</b><br><br>

Nun werden die Spalten vermischt
Es wird zunÃ¤chst jede Zelle einer Spalte mit einer Konstanten multipliziert und anschlieÃŸend die Ergebnisse XOR verknÃ¼pft
Hinter dieser Vorgehensweise steckt ein komplizierter mathematischer Zusammenhang, den ich hier nicht nÃ¤her erlÃ¤utere<br><br>
 

          <b>ENTSCHLÃœSSELUNG</b><br><br>

Hier wird rÃ¼ckwÃ¤rts vorgegangen
Die Daten werden zunÃ¤chst wieder in zweidimensionale Tabellen gelesen
Danach werden die RundenschlÃ¼ssel generiert
Allerdings wird nun mit der Schlussrunde angefangen und alle Funktionen in jeder Runde in der umgekehrten Reihenfolge aufgerufen
Durch die vielen XOR-VerknÃ¼pfungen unterscheiden sich die meisten Funktionen zum EntschlÃ¼sseln nicht von denen zum VerschlÃ¼sseln
Es muss eine andere S-Box genutzt werden (die sich aus der original S-Box berechnen lÃ¤sst) und die Zeilenverschiebungen erfolgen in die andere Richtung<br><br>
 

          <b>ANWENDUNGSBEREICHE</b><br><br>

AES findet einen sehr groÃŸen Anwendungsbereich, wie zum Beispiel fÃ¼r folgende Programme:<br>
VerschlÃ¼sselungsstandard IEEE 802.11i fÃ¼r Wireless LAN<br>
SRTP<br>
Skype<br>
Mac OS X als StandardverschlÃ¼sselungsmethode fÃ¼r Disk-Images<br>
FileVault<br>
Komprimierte Dateiarchive wie 7-ZIP oder RAR<br><br>
 

          <b>KRITIK</b><br><br>

Je nach verwendetem SchlÃ¼ssel besteht nur eine Sicherheitsmarge von drei (bei 128 Bits SchlÃ¼ssellÃ¤nge) bis fÃ¼nf Runden (bei 256 Bits SchlÃ¼ssellÃ¤nge)
Einfache algebraische Beschreibung der S-Boxen, die ihrerseits die einzige nichtlineare Komponente der Chiffre sind
Deshalb lÃ¤sst sich der gesamte Algorithmus als Gleichungssystem beschreiben
Durch den einfachen Key Schedule wÃ¼rden mit einem beliebigen RundenschlÃ¼ssel auch 128 Bit des VerfahrensschlÃ¼ssels kompromittiert          
          
          
          
 </p>   
      </div>
    
    
    

<!-- Cmap Bereich -->

  <div id="cmap" class="svg">
    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1173px" height="596px" style="background-color:#ffffff;">

        <!-- Connection Lines -->
            <g>
                <path d="M469 68L428 101" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M410 115L377 139" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M528 68L580 107" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M598 121L624 141" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M330 175L305 194" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M286 208L258 228" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M370 175L391 197" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M404 211L420 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M634 177L617 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M607 214L597 229" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M673 177L706 200" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
            <g>
                <path d="M725 214L747 231" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></path>
            </g>
        
        <!-- Linking Phrases -->
            <g>
                <g>
                    <text x="387px" y="113px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="557px" y="119px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="264px" y="206px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="366px" y="209px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="587px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan>
                    </text>
                </g>
            </g>
            <g>
                <g>
                    <text x="684px" y="212px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="8pt" font-family="Verdana">
                        <tspan>unterteilt</tspan><tspan fill="none">t</tspan><tspan>in</tspan>
                    </text>
                </g>
            </g>
        
        <!-- Concepts -->
            <g>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="450px" y="22px" rx="8" ry="8" width="93px" height="46px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="460px" y="54px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="16pt" font-family="Verdana">
                        <tspan>Thema</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="284px" y="139px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="291px" y="165px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="578px" y="141px" rx="8" ry="8" width="138px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="585px" y="167px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="14pt" font-family="Verdana">
                        <tspan>Oberthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="175px" y="228px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="185px" y="252px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>1</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="379px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="389px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>2</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="528px" y="229px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="538px" y="253px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>3</tspan>
                    </text>
                </g>
            </g>
            <g>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="none" fill="#edf4f6" stroke-width="0"></rect>
                <rect x="713px" y="231px" rx="8" ry="8" width="113px" height="36px" stroke="#000000" fill="none" stroke-width="1" stroke-dasharray="none"></rect>
                <g>
                    <text x="723px" y="255px" stroke="none" fill="#000000" stroke-width="1" stroke-dasharray="none" alignment-baseline="auto" text-anchor="start" text-decoration="normal" font-weight="normal" font-style="normal" font-size="10pt" font-family="Verdana">
                        <tspan>Unterthema</tspan><tspan fill="none">t</tspan><tspan>4</tspan>
                    </text>
                </g>
            </g>
        </svg>
  </div>
   
  <script type="text/javascript" src="navigation.js"></script>
</body>
</html>

